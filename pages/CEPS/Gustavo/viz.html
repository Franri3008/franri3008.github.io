<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    body {
      background: #ffffff;
      color: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif;
    }

    .viz-layout {
      width: 100%;
      height: 100vh;
      display: flex;
      align-items: stretch;
      overflow: hidden;
    }

    #container1 {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: 10px;
      box-sizing: border-box;
      gap: 8px;
    }

    .chart-section {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    .legend-section {
      flex: 0 0 auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .y-axis-container {
      flex: 0 0 clamp(28px, 3vw, 46px);
      display: flex;
      align-items: center;
      justify-content: flex-end;
      border-right: 1px solid rgba(0, 0, 0, 0.1);
      padding: 0 6px;
    }

    .y-axis-label {
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      text-align: center;
      font-weight: 600;
      font-size: clamp(6px, 1.2vw, 16px);
      color: #111;
    }

    .chart-wrapper {
      flex: 1;
      display: flex;
      height: 100%;
      margin-left: -6px;
    }

    #viz {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    #chart {
      display: block;
      width: 100%;
      height: 100%;
    }

    #tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.96);
      color: #333;
      border: 1px solid #cfd2d7;
      border-radius: 6px;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      pointer-events: none;
      opacity: 0;
      box-shadow: 0 0.25rem 0.875rem rgba(0, 0, 0, 0.08);
      transition: opacity 0.12s ease;
      max-width: 13.75rem;
    }

    .axis path,
    .axis line {
      stroke: #cfd2d7;
    }

    .axis text {
      fill: #111;
      font-size: 12px;
    }

    .x-axis text {
      font-size: clamp(6px, 1.2vw, 18px);
    }

    .y-axis text {
      font-size: clamp(6px, 1.2vw, 18px);
    }

    .grid line {
      stroke: rgba(230, 232, 239, 0.45);
    }

    .grid .domain {
      display: none;
    }

    .final-label {
      font-size: 0.65rem;
      font-weight: 600;
      fill: #111;
      alignment-baseline: middle;
      pointer-events: none;
      text-shadow: 0 0.0625rem 0.125rem #fff, 0 -0.0625rem 0.125rem #fff, 0.0625rem 0 0.125rem #fff, -0.0625rem 0 0.125rem #fff;
    }

    .connector {
      fill: none;
      stroke-width: 1.5;
      stroke-dasharray: 4 3;
      opacity: 0.8;
      pointer-events: none;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: clamp(6px, 1vw, 14px);
      background: rgba(255, 255, 255, 1);
      padding: clamp(4px, 1vh, 10px) clamp(10px, 2vw, 16px);
      border-radius: clamp(6px, 1vw, 12px);
      max-width: 100%;
      max-height: 100%;
      font-size: clamp(0.625rem, 1.4vw, 1rem);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: clamp(4px, 1vw, 8px);
      cursor: pointer;
      transition: opacity 0.2s ease;
      font-weight: 600;
      color: #333;
      font-size: inherit;
      padding: 2px 6px;
    }

    .legend-item.dim {
      opacity: 0.35;
    }

    .legend-item:focus-visible {
      outline: 2px solid rgba(0, 0, 0, 0.5);
      outline-offset: 2px;
    }

    .legend-square {
      width: clamp(8px, 0.9vw, 12px);
      height: clamp(8px, 0.9vw, 12px);
      border-radius: 4px;
      flex-shrink: 0;
    }

    .legend-line {
      width: clamp(16px, 2vw, 24px);
      height: 2px;
      flex-shrink: 0;
    }

    .legend-line.dashed {
      background: repeating-linear-gradient(
        to right,
        currentColor 0,
        currentColor 6px,
        transparent 6px,
        transparent 10px
      );
    }
  </style>
</head>

<body>
  <div class="viz-layout">
    <div id="container1">
      <div class="chart-section">
        <div class="y-axis-container">
          <div class="y-axis-label" id="yLabel">Retail Price (EUR/kWh)</div>
        </div>
        <div class="chart-wrapper">
          <div id="viz">
            <svg id="chart" role="img"></svg>
            <div id="tooltip"></div>
          </div>
        </div>
      </div>
      <div class="legend-section">
        <div class="legend" id="legend"></div>
      </div>
    </div>
  </div>

  <script>
    const LINE_COLORS = {
      'New': '#207264',
      'CEPS1': '#6b6b69',
      'CEPS2': '#0c2443',
      'CEPS3': '#b02441'
    };

    const SCATTER_COLOR = '#f3c74d';

    const svg = d3.select("#chart");
    const tooltip = d3.select("#tooltip");
    const yLabelEl = document.getElementById("yLabel");
    const vizEl = document.getElementById("viz");
    const formatComma = d3.format(",.0f");
    const formatShort = d3.format(".2s");

    let chartSeries = [];
    let scatterPoints = [];
    let timelineDates = [];
    let xScale = null;
    let yScale = null;
    let lineGenerator = null;
    let hiddenSeries = new Set();

    init();

    async function init() {
      try {
        const [data1, data2] = await Promise.all([
          fetchCSV("./data1.csv"),
          fetchCSV("./data2.csv")
        ]);

        const processed = buildSeries(data1);
        chartSeries = processed.series;
        timelineDates = processed.timeline;

        scatterPoints = buildScatterPoints(data2);

        buildLegend();
        render();
      } catch (err) {
        console.error("Failed to load visualization data:", err);
      }
    }

    function buildLegend() {
      const legendEl = document.getElementById('legend');
      if (!legendEl) return;

      legendEl.innerHTML = '';

      chartSeries.forEach(series => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.setAttribute('tabindex', '0');
        item.setAttribute('role', 'button');
        item.setAttribute('aria-pressed', 'true');
        item.dataset.seriesId = series.id;

        const line = document.createElement('div');
        const isDashed = isCEPSLine(series.id);
        line.className = isDashed ? 'legend-line dashed' : 'legend-line';

        if (isDashed) {
          line.style.color = getColor(series.id);
          line.style.backgroundColor = 'transparent';
        } else {
          line.style.backgroundColor = getColor(series.id);
        }

        const label = document.createElement('span');
        label.textContent = series.id;

        item.appendChild(line);
        item.appendChild(label);

        item.addEventListener('click', () => toggleSeries(series.id));
        item.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggleSeries(series.id);
          }
        });

        legendEl.appendChild(item);
      });

      if (scatterPoints.length > 0) {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.setAttribute('tabindex', '0');
        item.setAttribute('role', 'button');
        item.setAttribute('aria-pressed', 'true');
        item.dataset.seriesId = 'Repurposed';

        const square = document.createElement('div');
        square.className = 'legend-square';
        square.style.backgroundColor = SCATTER_COLOR;

        const label = document.createElement('span');
        label.textContent = 'Repurposed';

        item.appendChild(square);
        item.appendChild(label);

        item.addEventListener('click', () => toggleSeries('Repurposed'));
        item.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggleSeries('Repurposed');
          }
        });

        legendEl.appendChild(item);
      }
    }

    function toggleSeries(seriesId) {
      const legendEl = document.getElementById('legend');
      if (!legendEl) return;

      const item = legendEl.querySelector(`[data-series-id="${seriesId}"]`);
      if (!item) return;

      if (hiddenSeries.has(seriesId)) {
        hiddenSeries.delete(seriesId);
        item.classList.remove('dim');
        item.setAttribute('aria-pressed', 'true');
      } else {
        hiddenSeries.add(seriesId);
        item.classList.add('dim');
        item.setAttribute('aria-pressed', 'false');
      }

      render();
    }

    async function fetchCSV(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} while fetching ${url}`);
      }
      const text = await response.text();
      return d3.csvParse(text);
    }

    function buildSeries(rawData) {
      if (!Array.isArray(rawData) || !rawData.length) {
        return { series: [], timeline: [] };
      }

      const columns = Object.keys(rawData[0]).filter(col => col !== 'Year');
      const perGroup = [];

      columns.forEach(columnName => {
        const values = [];

        rawData.forEach(row => {
          const year = Number(row.Year);
          const rawValue = row[columnName];

          if (Number.isFinite(year) && rawValue !== '' && rawValue != null) {
            const value = Number(rawValue);
            if (Number.isFinite(value)) {
              values.push({ id: columnName, year, value });
            }
          }
        });

        if (values.length > 0) {
          values.sort((a, b) => a.year - b.year);
          perGroup.push({ id: columnName, values });
        }
      });

      if (!perGroup.length) {
        return { series: [], timeline: [] };
      }

      const allYears = new Set();
      perGroup.forEach(({ values }) => {
        values.forEach(({ year }) => {
          allYears.add(year);
        });
      });

      const timeline = Array.from(allYears).sort((a, b) => a - b);

      return { series: perGroup, timeline };
    }

    function buildScatterPoints(rawData) {
      if (!Array.isArray(rawData) || !rawData.length) {
        return [];
      }

      const points = [];
      rawData.forEach(row => {
        const year = Number(row.Year);
        const rawValue = row.point;

        if (Number.isFinite(year) && rawValue !== '' && rawValue != null) {
          const value = Number(rawValue);
          if (Number.isFinite(value)) {
            points.push({ year, value });
          }
        }
      });

      return points;
    }

    function formatValue(value) {
      if (!Number.isFinite(value)) return "0";
      const abs = Math.abs(value);
      if (abs >= 1e9) return formatShort(value).replace("G", "B");
      if (abs >= 1e6) return formatShort(value);
      if (abs >= 1e3) return formatShort(value);
      return formatComma(value);
    }

    function getColor(id) {
      return LINE_COLORS[id] || '#999999';
    }

    function isCEPSLine(id) {
      return id.startsWith('CEPS');
    }

    function render() {
      if (!chartSeries.length) {
        svg.selectAll("*").remove();
        return;
      }

      const rem = parseFloat(getComputedStyle(document.documentElement).fontSize);
      const margin = { top: 1 * rem, right: 2 * rem, bottom: 2 * rem, left: 3.5 * rem };
      const rect = vizEl.getBoundingClientRect();
      const width = rect.width || 960;
      const height = rect.height || 560;

      svg.attr("viewBox", `0 0 ${width} ${height}`);
      svg.attr("aria-label", "Line chart");

      const root = svg.selectAll("g.chart-root")
        .data([null])
        .join("g")
        .attr("class", "chart-root")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const allYears = timelineDates.length ? timelineDates : chartSeries.flatMap(s => s.values.map(p => p.year));
      if (!allYears.length) {
        svg.selectAll("*").remove();
        return;
      }

      let xDomain = d3.extent(allYears);
      xDomain[0] = Math.max(xDomain[0], 2015);

      const valuesFlat = chartSeries.flatMap(s => s.values.map(p => p.value));
      const maxValue = valuesFlat.length ? Math.max(...valuesFlat) : 100;

      xScale = d3.scaleLinear()
        .domain(xDomain)
        .range([0, width - margin.left - margin.right]);

      yScale = d3.scaleLinear()
        .domain([0, Math.max(1, maxValue)])
        .range([height - margin.top - margin.bottom, 0]);

      const innerW = xScale.range()[1];
      const baseDotR = Math.max(3, Math.min(6, Math.round(innerW / 250)));
      const dotR = baseDotR * 1.5;

      const allUniqueYears = Array.from(new Set([
        ...allYears,
        ...scatterPoints.map(p => p.year)
      ])).sort((a, b) => a - b);

      const xAxis = d3.axisBottom(xScale)
        .tickValues(allUniqueYears)
        .tickFormat(d3.format("d"));

      const yAxis = d3.axisLeft(yScale)
        .ticks(6)
        .tickFormat(formatValue);

      const grid = root.selectAll("g.grid-y")
        .data([null])
        .join("g")
        .attr("class", "grid grid-y")
        .call(d3.axisLeft(yScale).ticks(6).tickSize(-xScale.range()[1]).tickFormat(""));

      grid.select(".domain").remove();

      const xAxisGroup = root.selectAll("g.x-axis")
        .data([null])
        .join("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${yScale.range()[0]})`)
        .call(xAxis);

      const yAxisGroup = root.selectAll("g.y-axis")
        .data([null])
        .join("g")
        .attr("class", "axis y-axis")
        .call(yAxis);

      yAxisGroup.select(".domain").remove();

      lineGenerator = d3.line()
        .defined(point => Number.isFinite(point.value))
        .x(point => xScale(point.year))
        .y(point => yScale(point.value));

      const seriesGroups = root.selectAll("g.series-group")
        .data(chartSeries, d => d.id);

      const seriesEnter = seriesGroups.enter()
        .append("g")
        .attr("class", "series-group");

      seriesEnter.append("path")
        .attr("class", "series-line")
        .attr("fill", "none")
        .attr("stroke-width", 5);

      const seriesMerged = seriesEnter.merge(seriesGroups);

      seriesMerged.each(function (series) {
        const group = d3.select(this);
        const isHidden = hiddenSeries.has(series.id);
        group.style("display", isHidden ? "none" : null);

        if (isHidden) return;

        const linePath = group.select("path.series-line")
          .attr("stroke", getColor(series.id))
          .attr("d", lineGenerator(series.values));

        if (isCEPSLine(series.id)) {
          linePath.attr("stroke-dasharray", "8 4");
        } else {
          linePath.attr("stroke-dasharray", null);
        }
      });

      seriesGroups.exit().remove();

      const scatterGroup = root.selectAll("g.scatter-group")
        .data([null])
        .join("g")
        .attr("class", "scatter-group");

      const isScatterHidden = hiddenSeries.has('Repurposed');
      scatterGroup.style("display", isScatterHidden ? "none" : null);

      const scatterDots = scatterGroup.selectAll("circle.scatter-dot")
        .data(isScatterHidden ? [] : scatterPoints, (d, i) => `${d.year}-${d.value}-${i}`);

      scatterDots.enter()
        .append("circle")
        .attr("class", "scatter-dot")
        .attr("fill", SCATTER_COLOR)
        .attr("stroke", "#fff")
        .attr("stroke-width", 1.5)
        .attr("opacity", 0.7)
        .merge(scatterDots)
        .attr("r", dotR + 1)
        .attr("cx", d => xScale(d.year))
        .attr("cy", d => yScale(d.value))
        .on("mouseenter", function (event, point) {
          d3.select(this)
            .transition()
            .duration(120)
            .attr("r", dotR + 4)
            .attr("stroke-width", 2);
          showTooltip(event, { ...point, id: "Repurposed", seriesId: "Repurposed" });
        })
        .on("mousemove", function (event, point) {
          moveTooltip(event, { ...point, id: "Repurposed", seriesId: "Repurposed" });
        })
        .on("mouseleave", function () {
          d3.select(this)
            .transition()
            .duration(120)
            .attr("r", dotR + 1)
            .attr("stroke-width", 1.5);
          hideTooltip();
        });

      scatterDots.exit().remove();
    }

    function showTooltip(event, point) {
      tooltip.style("opacity", 1);
      moveTooltip(event, point);
    }

    function moveTooltip(event, point) {
      const [x, y] = d3.pointer(event, vizEl);

      const yearText = point.year ? point.year : "Unknown";
      const valueText = formatValue(point.value);

      tooltip.html(
        `<strong>${point.id || point.seriesId}</strong><br>` +
        `Year: ${yearText}<br>` +
        `Value: ${valueText}`
      );

      const ttNode = tooltip.node();
      const ttWidth = ttNode ? ttNode.offsetWidth : 0;
      const left = Math.max(6, x - ttWidth - 14);
      const top = Math.max(6, y - 28);

      tooltip.style("left", `${left}px`);
      tooltip.style("top", `${top}px`);
    }

    function hideTooltip() {
      tooltip.style("opacity", 0);
    }

    if (typeof ResizeObserver !== "undefined" && vizEl) {
      const chartObserver = new ResizeObserver(() => render());
      chartObserver.observe(vizEl);
    }

    window.addEventListener("resize", () => render());
    svg.on("mouseleave", hideTooltip);
  </script>
</body>

</html>
