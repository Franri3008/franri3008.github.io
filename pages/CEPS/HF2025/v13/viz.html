<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Daily open-source models</title>
  <style type="text/css">
    .knitr .inline {
      background-color: #F7F7F7;
      border: solid 1px #B0B0B0;
    }

    .error {
      font-weight: bold;
      color: #FF0000;
    }

    .warning {
      font-weight: bold;
    }

    .message {
      font-style: italic;
    }

    .source,
    .output,
    .warning,
    .error,
    .message {
      padding: 0 1em;
      border: solid 1px #F7F7F7;
    }

    .source {
      background-color: #F5F5F5;
    }

    .rimage .left {
      text-align: left;
    }

    .rimage .right {
      text-align: right;
    }

    .rimage .center {
      text-align: center;
    }

    body {
      margin: 0;
      overflow: hidden;
      height: 100vh;
      font-family: "Inter", "Segoe UI", Arial, sans-serif;
      background: #ffffff;
      color: #1f2933;
    }

    .viz-grid {
      display: grid;
      grid-template-rows: 19fr 1fr;
      grid-template-columns: 1fr 1fr;
      gap: clamp(8px, 1vh, 18px);
      height: 100vh;
      width: 100vw;
      padding: clamp(12px, 2vh, 24px);
      box-sizing: border-box;
    }

    .container {
      border-radius: 16px;
    }

    #container1 {
      grid-row: 1;
      grid-column: 1 / span 2;
      display: flex;
      flex-direction: column;
      padding: clamp(8px, 2vw, 20px);
      position: relative;
      overflow: hidden;
    }

    #container3 {
      grid-row: 4;
      grid-column: 1;
      display: flex;
      align-items: center;
      padding: 0 clamp(12px, 2vw, 20px);
      overflow: hidden;
    }

    #container4 {
      grid-row: 4;
      grid-column: 2;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 clamp(12px, 2vw, 20px);
      overflow: hidden;
    }

    #container4 a {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }

    #viz {
      width: 100%;
      height: 100%;
      flex: 1;
      min-height: 0;
      min-width: 0;
    }

    .source-text {
      font-size: clamp(12px, 1.5vw, 16px);
      font-weight: 600;
      color: #475569;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .source-text a {
      color: #2756d3;
      text-decoration: none;
    }

    .source-text a:hover {
      text-decoration: underline;
    }

    .logo {
      height: 100%;
      width: auto;
      max-height: clamp(36px, 6vh, 60px);
      max-width: 100%;
      pointer-events: auto;
      object-fit: contain;
    }

    .loading-state,
    .empty-state,
    .error-state {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(13px, 1.5vw, 16px);
      color: #475569;
      width: 100%;
      height: 100%;
      text-align: center;
    }

    .chart-tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(255, 255, 255, 0.98);
      border-radius: 12px;
      padding: 14px 16px;
      box-shadow: 0 18px 28px rgba(15, 23, 42, 0.15);
      border: 1px solid rgba(39, 86, 211, 0.15);
      min-width: 220px;
      max-width: 280px;
      font-size: 12px;
      color: #0f172a;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 10;
    }

    .tooltip-title {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .tooltip-value {
      font-size: 20px;
      font-weight: 700;
      color: #0f172a;
    }

    .tooltip-change {
      font-size: 12px;
      color: #2563eb;
      margin-bottom: 8px;
    }

    .tooltip-breakdown {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .tooltip-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
    }

    .tooltip-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #475569;
    }

    .tooltip-swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .tooltip-row strong {
      font-weight: 600;
      color: #111827;
      text-align: right;
    }

    .stacked-area-layer {
      opacity: 0.9;
    }

    .y-grid line {
      stroke: rgba(148, 163, 184, 0.35);
      stroke-dasharray: 3 4;
    }

    .y-grid .domain {
      display: none;
    }

    .x-axis text,
    .y-axis text {
      font-size: 14px;
      fill: #475569;
    }

    .x-axis path,
    .y-axis path,
    .x-axis line,
    .y-axis line {
      stroke: #d0d7e8;
    }

    .total-line {
      fill: none;
      stroke: #0f172a;
      stroke-width: 1.6;
    }

    .focus-line {
      stroke: rgba(15, 23, 42, 0.7);
      stroke-width: 1;
      opacity: 0;
      pointer-events: none;
    }

    .focus-dot {
      fill: #0f172a;
      stroke: #ffffff;
      stroke-width: 2;
      opacity: 0;
      pointer-events: none;
    }

    .interaction-overlay {
      cursor: crosshair;
    }

    .area-label {
      fill: #ffffff;
      font-size: 24px;
      font-weight: 700;
      text-anchor: end;
      paint-order: stroke;
      stroke: rgba(15, 23, 42, 0.45);
      stroke-width: 3px;
      stroke-linejoin: round;
    }

    .y-axis-label {
      font-size: 18px;
      fill: #475569;
    }

    .year-axis-label {
      font-size: 12px;
      font-weight: 600;
      fill: #0f172a;
    }

    .custom-title .title-text {
      font-size: clamp(18px, 3vh, 30px);
      font-weight: 700;
      fill: #0f172a;
    }

    .custom-title .subtitle-text {
      font-size: clamp(12px, 2vh, 18px);
      font-weight: 500;
      fill: #475569;
    }

    @media (max-height: 500px) {
      .viz-grid {
        grid-template-rows: 1fr;
        grid-template-columns: 1fr;
        padding: 0;
        gap: 0;
      }

      #container1 {
        grid-row: 1;
        grid-column: 1;
        padding: 0;
        border-radius: 0;
      }

      #container3,
      #container4 {
        display: none !important;
      }
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
  <div class="viz-grid">
    <div id="container1" class="container viz-container">
      <div id="viz" role="img" aria-label="Stacked line chart showing cumulative daily models by release year"></div>
    </div>
    <div id="container3" class="container source-container">
      <div class="source-text" id="source-text">
        Source:
        <a href="https://huggingface.co" target="_blank" rel="noopener">
          HuggingFace
        </a>
        &
        <a href="https://aiworld.eu" target="_blank" rel="noopener">
          AI World
        </a>
      </div>
    </div>
    <div id="container4" class="container logo-container">
      <a href="https://aiworld.eu/" id="logo-link" target="_blank" rel="noopener">
        <img src="https://aiworld.eu/logo-transparent.svg" class="logo" alt="AI World logo" />
      </a>
    </div>
  </div>

  <script>
    const SHOW_CONTAINER_3 = 1;
    const SHOW_CONTAINER_4 = 1;
    const VERTICAL_YEAR_COLORING = 1;
    const KEY_MOMENTS = [
      { date: '2024-10-18', subtitle: '1 Million Models Crossed' },
      { date: '2025-09-18', subtitle: '2 Million Models Crossed' }
    ];

    const KEY_MODELS = [
      { model: 'BLOOM', release_date: '2022-07-06', logo: 'bloom.jpg' },
      { model: 'LLaMA 2', release_date: '2023-07-28', logo: 'meta.jpg' },
      { model: 'Qwen2', release_date: '2024-06-07', logo: 'qwen.png' },
      { model: 'DeepSeek-R1', release_date: '2025-01-20', logo: 'deepseek.png' },
      { model: 'Kimi K2-Thinking', release_date: '2025-07-11', logo: 'kimi.png '}
    ];

    const DATA_PATH = 'daily_models.csv';
    const VIZ_CONTAINER_ID = 'viz';
    const COLOR_PALETTE = ['#5BB5C1', '#4A94C3', '#3355CB', '#6654DB'];
    const layoutMediaQuery = (typeof window !== 'undefined' && typeof window.matchMedia === 'function')
      ? window.matchMedia('(max-height: 500px)')
      : { matches: false };

    const parseDate = d3.utcParse('%Y-%m-%d');
    const formatTooltipDate = d3.utcFormat('%b %d, %Y');
    const formatAxisDate = d3.utcFormat('%b %Y');
    const numberFormatter = d3.format(',');
    const shortFormatter = value => d3.format('~s')(value).replace('G', 'B').toUpperCase();

    const vizContainer = document.getElementById(VIZ_CONTAINER_ID);
    const chartContainer = document.getElementById('container1');

    const tooltipElement = document.createElement('div');
    tooltipElement.className = 'chart-tooltip';
    chartContainer.appendChild(tooltipElement);

    let preparedRows = [];
    let stackKeys = [];
    let colorScale = null;
    let showCustomTitle = false;

    function hideTooltip() {
      tooltipElement.style.opacity = 0;
    }

    function prepareStackRows(rows) {
      const sorted = rows.slice().sort((a, b) => a.date - b.date);
      const uniqueYears = Array.from(new Set(sorted.map(d => d.date.getUTCFullYear()))).sort();
      const keys = uniqueYears.map(year => String(year));
      const runningTotals = {};
      keys.forEach(key => { runningTotals[key] = 0; });

      const processed = sorted.map((d, index) => {
        const previousValue = index === 0 ? 0 : sorted[index - 1].number;
        const increment = Math.max(0, d.number - previousValue);
        const yearKey = String(d.date.getUTCFullYear());
        runningTotals[yearKey] += increment;
        const entry = {
          date: d.date,
          number: d.number,
          dailyChange: increment
        };
        keys.forEach(key => {
          entry[key] = runningTotals[key];
        });
        return entry;
      });

      return { processed, keys };
    }

    function formatBreakdownRow(key, value, total) {
      const pct = total ? ((value / total) * 100).toFixed(1) : '0.0';
      return `
    <div class="tooltip-row">
      <span class="tooltip-label">
        <span class="tooltip-swatch" style="background:${colorScale(key)}"></span>
        ${key}
      </span>
      <strong>${numberFormatter(value)} (${pct}%)</strong>
    </div>
  `;
    }

    function renderVisualization(data, width, height) {
      if (!data.length || !vizContainer) {
        return;
      }

      hideTooltip();
      vizContainer.innerHTML = '';

      const isSmallWindow = height < 500 || width < 600;
      const margin = {
        top: 20,
        right: 32,
        bottom: isSmallWindow ? 30 : 55,
        left: isSmallWindow ? 60 : 90
      };
      const innerWidth = Math.max(0, width - margin.left - margin.right);
      const innerHeight = Math.max(0, height - margin.top - margin.bottom);

      if (!innerWidth || !innerHeight) {
        vizContainer.innerHTML = '<div class="empty-state">Not enough space to render the chart.</div>';
        return;
      }

      const yearLabelFontSize = Math.max(14, Math.min(32, Math.min(innerHeight * 0.045, innerWidth * 0.025)));
      const yearAxisFontSize = isSmallWindow
        ? 12
        : Math.max(16, Math.min(26, innerWidth * 0.03));

      const svg = d3.select(vizContainer)
        .append('svg')
        .attr('width', width)
        .attr('height', height);

      const chartGroup = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      if (showCustomTitle) {
        const titleOffsetX = Math.max(0, Math.min(24, innerWidth * 0.02));
        const titleOffsetY = Math.max(12, Math.min(36, innerHeight * 0.05));
        const subtitleSpacing = isSmallWindow ? 16 : 22;

        const titleGroup = chartGroup.append('g')
          .attr('class', 'custom-title')
          .attr('transform', `translate(${titleOffsetX}, ${titleOffsetY})`);

        titleGroup.append('text')
          .attr('class', 'title-text')
          .attr('x', 0)
          .attr('y', 0)
          .attr('text-anchor', 'start')
          .text('HF Models Increase Over the Years');

        titleGroup.append('text')
          .attr('class', 'subtitle-text')
          .attr('x', 0)
          .attr('y', subtitleSpacing)
          .attr('text-anchor', 'start')
          .text('I do not know what to write here');
      }

      const x = d3.scaleUtc()
        .domain(d3.extent(data, d => d.date))
        .range([0, innerWidth]);

      const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.number)]).nice()
        .range([innerHeight, 0]);

      const stackGenerator = d3.stack().keys(stackKeys);
      const stackedSeries = stackGenerator(data);

      chartGroup.append('g')
        .attr('class', 'y-grid')
        .call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(''));

      if (VERTICAL_YEAR_COLORING === 1) {
        const gradientId = 'year-gradient';
        const defs = svg.append('defs');
        const gradient = defs.append('linearGradient')
          .attr('id', gradientId)
          .attr('x1', '0%')
          .attr('x2', '100%')
          .attr('y1', '0%')
          .attr('y2', '0%');

        const minDate = data[0].date;
        const maxDate = data[data.length - 1].date;
        const totalTime = maxDate - minDate;

        stackKeys.forEach(year => {
          const yearStart = new Date(Date.UTC(parseInt(year), 0, 1));
          const yearEnd = new Date(Date.UTC(parseInt(year) + 1, 0, 1));

          let start = yearStart < minDate ? minDate : yearStart;
          let end = yearEnd > maxDate ? maxDate : yearEnd;

          if (start < end) {
            const startPct = ((start - minDate) / totalTime) * 100;
            const endPct = ((end - minDate) / totalTime) * 100;
            const color = colorScale(year);

            gradient.append('stop').attr('offset', startPct + '%').attr('stop-color', color);
            gradient.append('stop').attr('offset', endPct + '%').attr('stop-color', color);
          }
        });

        const areaTotal = d3.area()
          .x(d => x(d.date))
          .y0(innerHeight)
          .y1(d => y(d.number))
          .curve(d3.curveMonotoneX);

        chartGroup.append('path')
          .datum(data)
          .attr('class', 'total-area')
          .attr('fill', `url(#${gradientId})`)
          .attr('d', areaTotal)
          .attr('opacity', 0.9);

        stackKeys.forEach(year => {
          const yearStart = new Date(Date.UTC(parseInt(year), 0, 1));
          const yearEnd = new Date(Date.UTC(parseInt(year) + 1, 0, 1));

          let start = yearStart < minDate ? minDate : yearStart;
          let end = yearEnd > maxDate ? maxDate : yearEnd;

          if (start < end) {
          }

          if (yearStart > minDate && yearStart < maxDate) {
            chartGroup.append('line')
              .attr('x1', x(yearStart))
              .attr('x2', x(yearStart))
              .attr('y1', 0)
              .attr('y2', innerHeight)
              .attr('stroke', 'rgba(15, 23, 42, 0.2)')
              .attr('stroke-dasharray', '4 4');
          }
        });

      } else {
        const area = d3.area()
          .x(d => x(d.data.date))
          .y0(d => y(d[0]))
          .y1(d => y(d[1]))
          .curve(d3.curveMonotoneX);

        chartGroup.append('g')
          .attr('class', 'stacked-layers')
          .selectAll('.stacked-area-layer')
          .data(stackedSeries)
          .join('path')
          .attr('class', 'stacked-area-layer')
          .attr('fill', d => colorScale(d.key))
          .attr('d', area);
      }

      chartGroup.append('path')
        .datum(data)
        .attr('class', 'total-line')
        .attr('d', d3.line()
          .x(d => x(d.date))
          .y(d => y(d.number))
          .curve(d3.curveMonotoneX)
        );

      let yearAxisLabelData = [];

      if (VERTICAL_YEAR_COLORING !== 1) {
        const labelX = innerWidth - 10;
        const labelData = stackedSeries.map(series => {
          const lastPoint = series[series.length - 1];
          const yLower = y(lastPoint[0]);
          const yUpper = y(lastPoint[1]);
          const areaHeight = Math.abs(yLower - yUpper);
          if (areaHeight < 24) {
            return null;
          }
          const yPos = Math.max(yUpper + 12, yLower - 6);
          return { key: series.key, x: labelX, y: yPos };
        }).filter(Boolean);

        chartGroup.append('g')
          .attr('class', 'area-labels')
          .selectAll('text')
          .data(labelData)
          .join('text')
          .attr('class', 'area-label')
          .attr('x', d => d.x)
          .attr('y', d => d.y)
          .attr('text-anchor', 'end')
          .style('font-size', `${yearLabelFontSize}px`)
          .text(d => d.key);
      } else {
        const minDate = data[0].date;
        const maxDate = data[data.length - 1].date;

        yearAxisLabelData = stackKeys.map(year => {
          const yearStart = new Date(Date.UTC(parseInt(year), 0, 1));
          const yearEnd = new Date(Date.UTC(parseInt(year) + 1, 0, 1));

          let start = yearStart < minDate ? minDate : yearStart;
          let end = yearEnd > maxDate ? maxDate : yearEnd;

          if (start >= end) {
            return null;
          }
          const midTime = start.getTime() + (end.getTime() - start.getTime()) / 2;
          return {
            year,
            x: x(new Date(midTime))
          };
        }).filter(Boolean);
      }

      const xAxisTickCount = (VERTICAL_YEAR_COLORING === 1 || isSmallWindow)
        ? 0
        : Math.min(10, Math.floor(innerWidth / 90));
      const xAxis = d3.axisBottom(x)
        .ticks(xAxisTickCount)
        .tickFormat(VERTICAL_YEAR_COLORING === 1 ? (() => '') : formatAxisDate);

      chartGroup.append('g')
        .attr('class', 'x-axis')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(xAxis);

      if (yearAxisLabelData.length) {
        const labelY = innerHeight + (isSmallWindow ? 18 : 30);
        const yearLabelsGroup = chartGroup.append('g')
          .attr('class', 'year-axis-labels');
        yearLabelsGroup.selectAll('text')
          .data(yearAxisLabelData)
          .join('text')
          .attr('class', 'year-axis-label')
          .attr('x', d => d.x)
          .attr('y', labelY)
          .attr('text-anchor', 'middle')
          .style('font-size', `${yearAxisFontSize}px`)
          .text(d => d.year);
      }

      const yAxis = d3.axisLeft(y)
        .ticks(Math.min(5, Math.floor(innerHeight / 90)))
        .tickFormat(value => shortFormatter(value));

      chartGroup.append('g')
        .attr('class', 'y-axis')
        .call(yAxis);

      if (!isSmallWindow) {
        chartGroup.append('text')
          .attr('class', 'y-axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -margin.left + 24)
          .attr('text-anchor', 'middle')
          .text('Models');
      }

      const focusLine = chartGroup.append('line')
        .attr('class', 'focus-line')
        .attr('y1', 0)
        .attr('y2', innerHeight);

      const focusDot = chartGroup.append('circle')
        .attr('class', 'focus-dot')
        .attr('r', 4.5);

      const bisectDate = d3.bisector(d => d.date).left;

      if (KEY_MODELS && KEY_MODELS.length) {
        const modelsLinesGroup = chartGroup.append('g').attr('class', 'key-models-lines');
        const modelsGroup = chartGroup.append('g').attr('class', 'key-models');
        const logoSize = Math.max(30, Math.min(50, innerHeight * 0.06));
        const distanceFromLine = Math.max(15, Math.min(30, innerHeight * 0.04));
        const modelNameFontSize = Math.max(10, Math.min(14, innerHeight * 0.02));

        KEY_MODELS.forEach(modelInfo => {
          const mDate = parseDate(modelInfo.release_date);
          if (!mDate) return;

          const index = bisectDate(data, mDate);
          if (index < 0 || index >= data.length) return;
          const d = data[index];

          const xPos = x(mDate);
          const yPos = y(d.number);
          const logoYPosition = yPos - distanceFromLine - logoSize / 2;

          modelsLinesGroup.append('line')
            .attr('x1', xPos)
            .attr('x2', xPos)
            .attr('y1', logoYPosition + logoSize / 2)
            .attr('y2', yPos)
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '2 2')
            .attr('opacity', 0.5);

          const modelGroup = modelsGroup.append('g')
            .attr('transform', `translate(${xPos}, ${logoYPosition})`);

          const clipId = `clip-${modelInfo.model.replace(/\s+/g, '-')}`;
          let defs = svg.select('defs');
          if (defs.empty()) {
            defs = svg.append('defs');
          }
          defs.append('clipPath')
            .attr('id', clipId)
            .append('circle')
            .attr('cx', logoSize / 2)
            .attr('cy', logoSize / 2)
            .attr('r', logoSize / 2);

          modelGroup.append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', logoSize / 2)
            .attr('fill', '#ffffff');

          modelGroup.append('image')
            .attr('href', modelInfo.logo)
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', logoSize)
            .attr('height', logoSize)
            .attr('transform', `translate(${-logoSize / 2}, ${-logoSize / 2})`)
            .attr('clip-path', `url(#${clipId})`)
            .style('cursor', 'pointer');

          modelGroup.append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', logoSize / 2)
            .attr('fill', 'none')
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 2);

          if (!isSmallWindow) {
            modelGroup.append('text')
              .attr('x', -logoSize / 2 - 8)
              .attr('y', 4)
              .attr('text-anchor', 'end')
              .style('font-size', `${modelNameFontSize}px`)
              .attr('font-weight', '600')
              .attr('fill', '#0f172a')
              .text(modelInfo.model);
          }

          modelsGroup.append('circle')
            .attr('cx', xPos)
            .attr('cy', yPos)
            .attr('r', 4)
            .attr('fill', '#0f172a')
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 2);
        });
      }

      if (KEY_MOMENTS && KEY_MOMENTS.length) {
        const momentsGroup = chartGroup.append('g').attr('class', 'key-moments');
        const momentDateFormatter = d3.utcFormat('%b %d, %Y');
        const annotationYOffset = Math.max(20, Math.min(50, innerHeight * 0.08));
        const annotationXOffset = Math.max(6, Math.min(12, innerWidth * 0.015));
        const annotationLineOffset = isSmallWindow ? 4 : 8;
        const annotationSubtitleOffset = isSmallWindow ? 18 : 28;
        const keyMomentRightPadding = isSmallWindow ? Math.max(12, Math.min(30, innerWidth * 0.05)) : 0;

        KEY_MOMENTS.forEach(moment => {
          const mDate = parseDate(moment.date);
          if (!mDate) return;

          const index = bisectDate(data, mDate);
          if (index < 0 || index >= data.length) return;
          const d = data[index];

          const xPos = x(mDate);
          const yPos = y(d.number);
          const connectedLineTop = Math.max(0, yPos - annotationYOffset + annotationLineOffset);

          momentsGroup.append('line')
            .attr('x1', xPos)
            .attr('x2', xPos)
            .attr('y1', connectedLineTop)
            .attr('y2', innerHeight)
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '2 2')
            .attr('opacity', 0.7);

          const annotationXBase = xPos - annotationXOffset;
          const cappedAnnotationX = Math.min(annotationXBase, innerWidth - keyMomentRightPadding);

          const annotation = momentsGroup.append('g')
            .attr('transform', `translate(${cappedAnnotationX}, ${yPos - annotationYOffset})`);

          const dateText = annotation.append('text')
            .attr('x', 0)
            .attr('y', 0)
            .attr('text-anchor', 'end')
            .style('font-size', 'clamp(14px, 2.5vh, 24px)')
            .attr('font-weight', '700')
            .attr('fill', '#0f172a')
            .text(momentDateFormatter(mDate));

          const textWidth = dateText.node().getComputedTextLength() || 100;

          annotation.append('line')
            .attr('x1', 0)
            .attr('x2', -textWidth)
            .attr('y1', annotationLineOffset)
            .attr('y2', annotationLineOffset)
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 2);

          annotation.append('text')
            .attr('x', 0)
            .attr('y', annotationSubtitleOffset)
            .attr('text-anchor', 'end')
            .style('font-size', 'clamp(8px, 2vh, 14px)')
            .attr('fill', '#475569')
            .text(moment.subtitle);

          momentsGroup.append('circle')
            .attr('cx', xPos)
            .attr('cy', yPos)
            .attr('r', 8)
            .attr('fill', '#0f172a')
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 2);
        });
      }

      if (KEY_MOMENTS && KEY_MOMENTS.length && data.length) {
        const intervalsGroup = chartGroup.append('g')
          .attr('class', 'moment-intervals')
          .attr('data-priority', '-1');
        intervalsGroup.lower();
        const labelsGroup = !isSmallWindow ? chartGroup.append('g')
          .attr('class', 'moment-interval-labels') : null;
        if (labelsGroup) {
          labelsGroup.raise();
        }

        const allMoments = [
          { date: data[0].date, isStart: true },
          ...KEY_MOMENTS.map(m => ({ date: parseDate(m.date), isStart: false }))
        ].sort((a, b) => a.date - b.date);

        const momentCoords = allMoments.map(m => {
          const index = bisectDate(data, m.date);
          const safeIndex = Math.max(0, Math.min(data.length - 1, index));
          const d = data[safeIndex];

          if (!d) return null;
          const yPos = y(d.number);
          return {
            date: m.date,
            x: x(m.date),
            y: yPos
          };
        }).filter(Boolean);

        if (momentCoords.length > 0) {
          const start = momentCoords[0];
          intervalsGroup.append('line')
            .attr('x1', start.x)
            .attr('x2', start.x)
            .attr('y1', start.y)
            .attr('y2', innerHeight)
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '2 2')
            .attr('opacity', 0.4);
        }

        for (let i = 0; i < momentCoords.length - 1; i++) {
          const start = momentCoords[i];
          const end = momentCoords[i + 1];

          const days = Math.round((end.date - start.date) / (1000 * 60 * 60 * 24));
          const midX = (start.x + end.x) / 2;
          const midY = (start.y + end.y) / 2;

          intervalsGroup.append('line')
            .attr('x1', start.x)
            .attr('x2', end.x)
            .attr('y1', start.y)
            .attr('y2', end.y)
            .attr('stroke', '#475569')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '4 4');

          if (labelsGroup) {
            const labelGroup = labelsGroup.append('g')
              .attr('transform', `translate(${midX}, ${midY + 4})`);

            const labelText = labelGroup.append('text')
              .attr('x', 0)
              .attr('y', 0)
              .attr('text-anchor', 'middle')
              .attr('font-size', '11px')
              .attr('font-weight', '500')
              .attr('fill', '#475569')
              .text(`${numberFormatter(days)} days`);

            const labelBox = labelText.node().getBBox();
            const paddingX = 8;
            const paddingY = 4;

            labelGroup.insert('rect', 'text')
              .attr('x', labelBox.x - paddingX)
              .attr('y', labelBox.y - paddingY)
              .attr('width', labelBox.width + paddingX * 2)
              .attr('height', labelBox.height + paddingY * 2)
              .attr('fill', '#ffffff')
              .attr('stroke', '#d7dce7')
              .attr('stroke-width', 1.5)
              .attr('rx', 6)
              .attr('ry', 6);
          }
        }
      }

      const overlay = chartGroup.append('rect')
        .attr('class', 'interaction-overlay')
        .attr('width', innerWidth)
        .attr('height', innerHeight)
        .attr('fill', 'transparent');

      overlay
        .on('mousemove', function (event) {
          const [mx, my] = d3.pointer(event, this);
          if (mx < 0 || mx > innerWidth || my < 0 || my > innerHeight) {
            focusLine.style('opacity', 0);
            focusDot.style('opacity', 0);
            hideTooltip();
            return;
          }
          const hoveredDate = x.invert(mx);
          const index = Math.min(Math.max(bisectDate(data, hoveredDate), 1), data.length - 1);
          const d0 = data[index - 1];
          const d1 = data[index];
          const d = hoveredDate - d0.date > d1.date - hoveredDate ? d1 : d0;

          const xPos = x(d.date);
          const yPos = y(d.number);

          focusLine
            .attr('x1', xPos)
            .attr('x2', xPos)
            .style('opacity', 1);

          focusDot
            .attr('cx', xPos)
            .attr('cy', yPos)
            .style('opacity', 1);

          const breakdownHtml = stackKeys.map(key => formatBreakdownRow(key, d[key], d.number)).join('');
          tooltipElement.innerHTML = `
        <div class="tooltip-title">${formatTooltipDate(d.date)}</div>
        <div class="tooltip-value">${numberFormatter(d.number)} models</div>
        <div class="tooltip-change">+${numberFormatter(d.dailyChange)} new</div>
        <div class="tooltip-breakdown">${breakdownHtml}</div>
      `;
          tooltipElement.style.opacity = 1;

          const tooltipWidth = tooltipElement.offsetWidth || 240;
          const tooltipHeight = tooltipElement.offsetHeight || 120;
          const containerWidth = vizContainer.clientWidth;
          const containerHeight = vizContainer.clientHeight;
          let left = margin.left + xPos + 16;
          if (left + tooltipWidth > containerWidth) {
            left = margin.left + xPos - tooltipWidth - 16;
          }
          left = Math.max(8, Math.min(containerWidth - tooltipWidth - 8, left));
          let top = margin.top + yPos - tooltipHeight - 12;
          if (top < 8) {
            top = margin.top + yPos + 12;
          }
          top = Math.max(8, Math.min(containerHeight - tooltipHeight - 8, top));
          tooltipElement.style.left = `${left}px`;
          tooltipElement.style.top = `${top}px`;
        })
        .on('mouseleave', function () {
          focusLine.style('opacity', 0);
          focusDot.style('opacity', 0);
          hideTooltip();
        });
    }

    function renderVisualizationForContainer() {
      if (!vizContainer || !preparedRows.length) {
        return;
      }
      const rect = vizContainer.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      renderVisualization(preparedRows, width, height);
    }

    function loadData() {
      if (vizContainer) {
        vizContainer.innerHTML = '<div class="loading-state">Loading daily model countsâ€¦</div>';
      }

      d3.csv(DATA_PATH, row => {
        const date = parseDate(row.date);
        const number = Number(row.number);
        if (!date || Number.isNaN(number)) {
          return null;
        }
        return { date, number };
      }).then(rows => {
        const validRows = rows.filter(Boolean);
        if (!validRows.length) {
          vizContainer.innerHTML = '<div class="empty-state">No data found in daily_models.csv.</div>';
          return;
        }
        const result = prepareStackRows(validRows);
        preparedRows = result.processed;
        stackKeys = result.keys;
        colorScale = d3.scaleOrdinal()
          .domain(stackKeys)
          .range(stackKeys.map((key, idx) => COLOR_PALETTE[idx % COLOR_PALETTE.length]));
        renderVisualizationForContainer();
      }).catch(error => {
        console.error(error);
        if (vizContainer) {
          vizContainer.innerHTML = '<div class="error-state">Unable to load the CSV data.</div>';
        }
      });
    }

    const updateContainerVisibility = function () {
      const vizGrid = document.querySelector('.viz-grid');
      const container1 = document.getElementById('container1');
      const container3 = document.getElementById('container3');
      const container4 = document.getElementById('container4');
      const isCompact = layoutMediaQuery && layoutMediaQuery.matches;

      if (isCompact) {
        if (container3) {
          container3.style.display = 'none';
          container3.style.gridRow = '';
          container3.style.gridColumn = '';
        }
        if (container4) {
          container4.style.display = 'none';
          container4.style.gridRow = '';
          container4.style.gridColumn = '';
        }
        if (vizGrid) {
          vizGrid.style.gridTemplateRows = '1fr';
          vizGrid.style.gridTemplateColumns = '1fr';
        }
        if (container1) {
          container1.style.gridRow = '1';
          container1.style.gridColumn = '1';
        }
        return;
      }

      if (container3) {
        container3.style.display = SHOW_CONTAINER_3 ? 'flex' : 'none';
        container3.style.gridRow = '';
        container3.style.gridColumn = '';
      }
      if (container4) {
        container4.style.display = SHOW_CONTAINER_4 ? 'flex' : 'none';
        container4.style.gridRow = '';
        container4.style.gridColumn = '';
      }

      const lowerRowVisible = (SHOW_CONTAINER_3 && container3) || (SHOW_CONTAINER_4 && container4);

      const gridRows = [];
      let currentRow = 1;
      const container1Height = 20 - (lowerRowVisible ? 1 : 0);
      gridRows.push(`${container1Height}fr`);

      if (lowerRowVisible) {
        gridRows.push('1fr');
        currentRow += 1;
        if (SHOW_CONTAINER_3 && container3) {
          container3.style.gridRow = currentRow.toString();
        }
        if (SHOW_CONTAINER_4 && container4) {
          container4.style.gridRow = currentRow.toString();
        }
        if (SHOW_CONTAINER_3 && !SHOW_CONTAINER_4 && container3) {
          container3.style.gridColumn = '1 / span 2';
        } else if (!SHOW_CONTAINER_3 && SHOW_CONTAINER_4 && container4) {
          container4.style.gridColumn = '1 / span 2';
        } else {
          if (container3) container3.style.gridColumn = '1';
          if (container4) container4.style.gridColumn = '2';
        }
      }

      if (vizGrid) {
        vizGrid.style.gridTemplateRows = gridRows.join(' ');
        vizGrid.style.gridTemplateColumns = '1fr 1fr';
      }
      if (container1) {
        container1.style.gridRow = '1';
        container1.style.gridColumn = '1 / span 2';
      }
    };

    const handleResize = function () {
      updateContainerVisibility();
      renderVisualizationForContainer();
    };

    let resizeTimer;

    window.addEventListener('resize', function () {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(handleResize, 120);
    });

    if (layoutMediaQuery && layoutMediaQuery.addEventListener) {
      layoutMediaQuery.addEventListener('change', handleResize);
    } else if (layoutMediaQuery && layoutMediaQuery.addListener) {
      layoutMediaQuery.addListener(handleResize);
    }

    updateContainerVisibility();

    if (typeof ResizeObserver !== 'undefined' && vizContainer) {
      const resizeObserver = new ResizeObserver(function () {
        renderVisualizationForContainer();
      });
      resizeObserver.observe(vizContainer);
    }

    document.addEventListener('keydown', function (event) {
      if (!event || typeof event.key !== 'string') return;
      if (event.key.toLowerCase() === 't') {
        showCustomTitle = !showCustomTitle;
        renderVisualizationForContainer();
      }
    });

    loadData();
  </script>
</body>

</html>
