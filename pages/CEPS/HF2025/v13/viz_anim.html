<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Daily open-source models</title>
  <style type="text/css">
    .knitr .inline {
      background-color: #F7F7F7;
      border: solid 1px #B0B0B0;
    }

    .error {
      font-weight: bold;
      color: #FF0000;
    }

    .warning {
      font-weight: bold;
    }

    .message {
      font-style: italic;
    }

    .source,
    .output,
    .warning,
    .error,
    .message {
      padding: 0 1em;
      border: solid 1px #F7F7F7;
    }

    .source {
      background-color: #F5F5F5;
    }

    .rimage .left {
      text-align: left;
    }

    .rimage .right {
      text-align: right;
    }

    .rimage .center {
      text-align: center;
    }

    body {
      margin: 0;
      overflow: hidden;
      height: 100vh;
      font-family: "Inter", "Segoe UI", Arial, sans-serif;
      background: #ffffff;
      color: #1f2933;
    }

    .viz-grid {
      display: grid;
      grid-template-rows: 19fr 1fr;
      grid-template-columns: 1fr 1fr;
      gap: clamp(8px, 1vh, 18px);
      height: 100vh;
      width: 100vw;
      padding: clamp(12px, 2vh, 24px);
      box-sizing: border-box;
    }

    .container {
      border-radius: 0px;
    }

    #container1 {
      grid-row: 1;
      grid-column: 1 / span 2;
      display: flex;
      flex-direction: column;
      padding: 0px;
      position: relative;
      overflow: hidden;
    }

    #container3 {
      grid-row: 4;
      grid-column: 1;
      display: flex;
      align-items: center;
      padding: 0 clamp(12px, 2vw, 20px);
      overflow: visible;
    }

    #container4 {
      grid-row: 4;
      grid-column: 2;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: nowrap;
      gap: clamp(10px, 1vw, 24px);
      padding: 0 clamp(12px, 2vw, 20px);
      overflow: visible;
    }

    .logo-pair {
      display: inline-flex;
      align-items: center;
      justify-content: flex-end;
      gap: clamp(8px, 1vw, 16px);
      flex-wrap: nowrap;
      flex: 0 1 auto;
      min-width: 0;
    }

    #container4 a {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      max-width: 100%;
      flex: 0 1 auto;
    }

    #viz {
      width: 100%;
      height: 100%;
      flex: 1;
      min-height: 0;
      min-width: 0;
    }

    .source-text {
      font-size: clamp(12px, 1.5vw, 16px);
      font-weight: 600;
      color: #475569;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .source-text a {
      color: #2756d3;
      text-decoration: none;
    }

    .source-text a:hover {
      text-decoration: underline;
    }

    .logo {
      height: auto;
      width: auto;
      max-height: clamp(28px, 5vh, 60px);
      max-width: clamp(60px, 16vw, 140px);
      pointer-events: auto;
      object-fit: contain;
    }

    .restart-button {
      border: none;
      border-radius: 6px;
      background: #2756d3;
      color: #ffffff;
      font-weight: 400;
      font-size: clamp(18px, 2vw, 26px);
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: opacity 0.4s ease, transform 0.4s ease;
      flex: 0 0 auto;
      width: clamp(44px, 4vw, 60px);
      height: clamp(20px, 4vw, 40px);
      margin-right: clamp(8px, 1vw, 16px);
    }

    .restart-button.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .restart-button::before {
      content: '↻';
      line-height: 1;
    }

    .restart-button.skip-mode::before {
      content: '⏭';
    }

    .loading-state,
    .empty-state,
    .error-state {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(13px, 1.5vw, 16px);
      color: #475569;
      width: 100%;
      height: 100%;
      text-align: center;
    }

    .chart-tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(255, 255, 255, 0.98);
      border-radius: 12px;
      padding: 14px 16px;
      border: 1px solid rgba(39, 86, 211, 0.15);
      min-width: 220px;
      max-width: 280px;
      font-size: 12px;
      color: #0f172a;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 10;
    }

    .tooltip-title {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .tooltip-value {
      font-size: 20px;
      font-weight: 700;
      color: #0f172a;
    }

    .tooltip-change {
      font-size: 12px;
      color: #2563eb;
      margin-bottom: 8px;
    }

    .tooltip-breakdown {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .tooltip-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
    }

    .tooltip-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #475569;
    }

    .tooltip-swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .tooltip-row strong {
      font-weight: 600;
      color: #111827;
      text-align: right;
    }

    .stacked-area-layer {
      opacity: 0.9;
    }

    .y-grid line {
      stroke: rgba(148, 163, 184, 0.35);
      stroke-dasharray: 3 4;
    }

    .y-grid .domain {
      display: none;
    }

    .x-axis text,
    .y-axis text {
      font-size: 14px;
      fill: #475569;
    }

    .x-axis path,
    .y-axis path,
    .x-axis line,
    .y-axis line {
      stroke: #d0d7e8;
    }

    .total-line {
      fill: none;
      stroke: #0f172a;
      stroke-width: 1.6;
    }

    .focus-line {
      stroke: rgba(15, 23, 42, 0.7);
      stroke-width: 1;
      opacity: 0;
      pointer-events: none;
    }

    .focus-dot {
      fill: #0f172a;
      stroke: #ffffff;
      stroke-width: 2;
      opacity: 0;
      pointer-events: none;
    }

    .interaction-overlay {
      cursor: crosshair;
    }

    .current-pointer {
      pointer-events: none;
    }

    .current-pointer-line {
      stroke: rgba(15, 23, 42, 0.5);
      stroke-width: 1;
      stroke-dasharray: 4 4;
    }

    .current-pointer-dot {
      fill: #2563eb;
      stroke: #ffffff;
      stroke-width: 2;
    }

    .current-pointer-label {
      font-size: clamp(10px, 1.8vh, 18px);
      font-weight: 600;
      fill: #0f172a;
      text-anchor: middle;
      paint-order: stroke;
      stroke: #ffffff;
      stroke-width: 3px;
      stroke-linejoin: round;
    }

    .area-label {
      fill: #ffffff;
      font-size: 24px;
      font-weight: 700;
      text-anchor: end;
      paint-order: stroke;
      stroke: rgba(15, 23, 42, 0.45);
      stroke-width: 3px;
      stroke-linejoin: round;
    }

    .y-axis-label {
      font-size: clamp(12px, 2vh, 24px);
      fill: #475569;
    }

    .year-axis-label {
      font-size: 12px;
      font-weight: 600;
      fill: #0f172a;
    }

    .custom-title {
      opacity: 0;
      transition: opacity 0.025s ease;
      pointer-events: none;
    }

    .custom-title .title-text {
      font-size: clamp(24px, 5vh, 52px);
      font-weight: 700;
      fill: #0f172a;
    }

    .custom-title .subtitle-text {
      font-size: clamp(16px, 3vh, 32px);
      font-weight: 500;
      fill: #475569;
    }

    @media (max-width: 720px) {
      #container4 {
        justify-content: center;
      }

      .logo-pair {
        justify-content: center;
      }

      .restart-button {
        width: 48px;
        height: 24px;
      }
    }

    @media (max-height: 500px) {
      .viz-grid {
        grid-template-rows: 1fr;
        grid-template-columns: 1fr;
        padding: 0;
        gap: 0;
      }

      #container1 {
        grid-row: 1;
        grid-column: 1;
        padding: 0;
        border-radius: 0;
      }

      #container3,
      #container4 {
        display: none !important;
      }
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>

<body>
  <div class="viz-grid">
    <div id="container1" class="container viz-container">
      <div id="viz" role="img" aria-label="Stacked line chart showing cumulative daily models by release year"></div>
    </div>
    <div id="container3" class="container source-container">
      <div class="source-text" id="source-text">
        Source:
        <a href="https://huggingface.co" target="_blank" rel="noopener">
          HuggingFace
        </a>
        &
        <a href="https://aiworld.eu" target="_blank" rel="noopener">
          AI World
        </a>
      </div>
    </div>
    <div id="container4" class="container logo-container">
      <button id="restart-animation" class="restart-button" type="button"></button>
      <div class="logo-pair">
        <a href="https://huggingface.co/" id="logo-link" target="_blank" rel="noopener">
          <img src="https://huggingface.co/front/assets/huggingface_logo-noborder.svg" class="logo"
            alt="Hugging Face logo" />
        </a>
        ×
        <a href="https://aiworld.eu/" id="logo-link" target="_blank" rel="noopener">
          <img src="https://aiworld.eu/logo-transparent.svg" class="logo" alt="AI World logo" />
        </a>
      </div>
    </div>
  </div>

  <script>
    const SHOW_CONTAINER_3 = 1;
    const SHOW_CONTAINER_4 = 1;
    const VERTICAL_YEAR_COLORING = 1;
    const KEY_MOMENTS = [
      { date: '2022-12-29', label: '100K' },
      { date: '2024-03-01', label: '500K' },
      { date: '2024-10-19', label: '1M' },
      { date: '2025-09-19', label: '2M' }
    ];

    const KEY_MODELS = [
      { model: 'BLOOM', release_date: '2022-07-06', logo: 'bloom.jpg' },
      { model: 'LLaMA 2', release_date: '2023-07-28', logo: 'meta.jpg' },
      { model: 'Qwen2', release_date: '2024-06-07', logo: 'qwen.png' },
      { model: 'Flux 1.0', release_date: '2024-08-01', logo: 'bfl.png' },
      { model: 'DeepSeek-R1', release_date: '2025-01-20', logo: 'deepseek.png' },
      { model: 'GPT-OSS', release_date: '2025-08-05', logo: 'gpt.jpg' },
      { model: 'Kimi K2-Thinking', release_date: '2025-11-07', logo: 'kimi.png ' }
    ];

    const CHART_ANIMATION_DURATION = 14000;
    const CHART_ANIMATION_DELAY = 400;

    const DATA_PATH = 'daily_models.csv';
    const VIZ_CONTAINER_ID = 'viz';
    const COLOR_PALETTE = ['#5BB5C1', '#4A94C3', '#3355CB', '#6654DB'];
    const layoutMediaQuery = (typeof window !== 'undefined' && typeof window.matchMedia === 'function')
      ? window.matchMedia('(max-height: 500px)')
      : { matches: false };

    const parseDate = d3.utcParse('%Y-%m-%d');
    const formatTooltipDate = d3.utcFormat('%b %d, %Y');
    const formatAxisDate = d3.utcFormat('%b %Y');
    const numberFormatter = d3.format(',');
    const shortFormatter = value => d3.format('~s')(value).replace('G', 'B').toUpperCase();

    const vizContainer = document.getElementById(VIZ_CONTAINER_ID);
    const chartContainer = document.getElementById('container1');
    const restartButton = document.getElementById('restart-animation');

    const tooltipElement = document.createElement('div');
    tooltipElement.className = 'chart-tooltip';
    chartContainer.appendChild(tooltipElement);

    let preparedRows = [];
    let stackKeys = [];
    let colorScale = null;
    const getUrlBooleanParam = (param, defaultValue = false) => {
      if (typeof window === 'undefined' || !window.location) return defaultValue;
      try {
        const params = new URLSearchParams(window.location.search || '');
        if (!params.has(param)) return defaultValue;
        const value = (params.get(param) || '').trim().toLowerCase();
        if (!value) return defaultValue;
        return value === '1' || value === 'true' || value === 'yes' || value === 'on';
      } catch (error) {
        console.warn(`Unable to read URL parameter "${param}"`, error);
        return defaultValue;
      }
    };
    const updateUrlBooleanParam = (param, value) => {
      if (typeof window === 'undefined' || !window.history || typeof window.history.replaceState !== 'function') return;
      try {
        const url = new URL(window.location.href);
        if (value) {
          url.searchParams.set(param, '1');
        } else {
          url.searchParams.delete(param);
        }
        window.history.replaceState({}, '', url);
      } catch (error) {
        console.warn(`Unable to update URL parameter "${param}"`, error);
      }
    };
    let showCustomTitle = getUrlBooleanParam('title', false);
    let shouldAnimate = getUrlBooleanParam('anim', true);
    let activeAnimationFrame = null;
    let restartAnimationHandler = null;
    let skipAnimationHandler = null;
    const BUTTON_MODES = {
      SKIP: 'skip',
      RESTART: 'restart'
    };
    let currentButtonMode = BUTTON_MODES.RESTART;

    function hideTooltip() {
      tooltipElement.style.opacity = 0;
    }

    function setButtonMode(mode) {
      if (!restartButton || !mode) return;
      currentButtonMode = mode;
      restartButton.classList.add('visible');
      const isSkip = mode === BUTTON_MODES.SKIP;
      restartButton.classList.toggle('skip-mode', isSkip);
      const label = isSkip ? 'Skip animation' : 'Restart animation';
      restartButton.title = label;
      restartButton.setAttribute('aria-label', label);
    }

    function animateTitleVisibility(visible, animate = true) {
      if (!vizContainer) return false;
      const titleNode = vizContainer.querySelector('svg .custom-title');
      if (!titleNode) return false;
      const selection = d3.select(titleNode);
      selection.interrupt();
      if (animate) {
        selection.transition()
          .duration(500)
          .style('opacity', visible ? 1 : 0);
      } else {
        selection.style('opacity', visible ? 1 : 0);
      }
      return true;
    }

    function getMomentLabel(moment) {
      if (!moment) return '';
      if (moment.label) return String(moment.label);
      const subtitle = (moment.subtitle || '').trim();
      if (!subtitle) return '';
      const millionMatch = subtitle.match(/(\d+(?:\.\d+)?)\s*million/i);
      if (millionMatch) {
        const value = millionMatch[1].replace(/\.0+$/, '');
        return `${value}M`;
      }
      const kMatch = subtitle.match(/(\d+(?:\.\d+)?)\s*k/i);
      if (kMatch) {
        const value = kMatch[1].replace(/\.0+$/, '');
        return `${value}K`;
      }
      const numberMatch = subtitle.match(/(\d+(?:\.\d+)?)/);
      if (numberMatch) {
        return numberMatch[1];
      }
      return subtitle;
    }

    if (restartButton) {
      restartButton.addEventListener('click', () => {
        if (currentButtonMode === BUTTON_MODES.SKIP) {
          if (typeof skipAnimationHandler === 'function') {
            skipAnimationHandler();
          }
          return;
        }
        if (typeof restartAnimationHandler === 'function') {
          restartAnimationHandler();
        }
      });
    }

    function cancelActiveAnimation() {
      if (activeAnimationFrame !== null && typeof window !== 'undefined' && window.cancelAnimationFrame) {
        window.cancelAnimationFrame(activeAnimationFrame);
      }
      activeAnimationFrame = null;
    }

    function startRevealAnimation(config) {
      const {
        clipRect,
        targetWidth,
        duration = CHART_ANIMATION_DURATION,
        delay = CHART_ANIMATION_DELAY,
        onProgress,
        onComplete
      } = config || {};

      if (!clipRect || !targetWidth || targetWidth <= 0 || typeof window === 'undefined' || !window.requestAnimationFrame) {
        if (clipRect && targetWidth) {
          clipRect.attr('width', targetWidth);
        }
        if (typeof onProgress === 'function') {
          onProgress(1);
        }
        if (typeof onComplete === 'function') {
          onComplete();
        }
        return;
      }

      cancelActiveAnimation();
      clipRect.attr('width', 0);

      const nowFn = (typeof performance !== 'undefined' && performance.now)
        ? () => performance.now()
        : () => Date.now();
      const startTimestamp = nowFn() + Math.max(0, delay);

      const step = (timestamp) => {
        if (timestamp < startTimestamp) {
          activeAnimationFrame = window.requestAnimationFrame(step);
          return;
        }
        const elapsed = timestamp - startTimestamp;
        const progress = Math.min(1, elapsed / duration);
        clipRect.attr('width', targetWidth * progress);
        if (typeof onProgress === 'function') {
          onProgress(progress);
        }
        if (progress < 1) {
          activeAnimationFrame = window.requestAnimationFrame(step);
        } else {
          if (typeof onComplete === 'function') {
            onComplete();
          }
          activeAnimationFrame = null;
        }
      };

      activeAnimationFrame = window.requestAnimationFrame(step);
    }

    function prepareStackRows(rows) {
      const sorted = rows.slice().sort((a, b) => a.date - b.date);
      const uniqueYears = Array.from(new Set(sorted.map(d => d.date.getUTCFullYear()))).sort();
      const keys = uniqueYears.map(year => String(year));
      const runningTotals = {};
      keys.forEach(key => { runningTotals[key] = 0; });

      const processed = sorted.map((d, index) => {
        const previousValue = index === 0 ? 0 : sorted[index - 1].number;
        const increment = Math.max(0, d.number - previousValue);
        const yearKey = String(d.date.getUTCFullYear());
        runningTotals[yearKey] += increment;
        const entry = {
          date: d.date,
          number: d.number,
          dailyChange: increment
        };
        keys.forEach(key => {
          entry[key] = runningTotals[key];
        });
        return entry;
      });

      return { processed, keys };
    }

    function formatBreakdownRow(key, value, total) {
      const pct = total ? ((value / total) * 100).toFixed(1) : '0.0';
      return `
    <div class="tooltip-row">
      <span class="tooltip-label">
        <span class="tooltip-swatch" style="background:${colorScale(key)}"></span>
        ${key}
      </span>
      <strong>${numberFormatter(value)} (${pct}%)</strong>
    </div>
  `;
    }

    function renderVisualization(data, width, height) {
      if (!data.length || !vizContainer) {
        return;
      }

      hideTooltip();
      vizContainer.innerHTML = '';
      cancelActiveAnimation();
      restartAnimationHandler = null;
      skipAnimationHandler = null;

      const isSmallWindow = height < 500 || width < 600;
      const margin = {
        top: 20,
        right: 32,
        bottom: isSmallWindow ? 30 : 55,
        left: isSmallWindow ? 60 : 90
      };
      const innerWidth = Math.max(0, width - margin.left - margin.right);
      const innerHeight = Math.max(0, height - margin.top - margin.bottom);

      if (!innerWidth || !innerHeight) {
        vizContainer.innerHTML = '<div class="empty-state">Not enough space to render the chart.</div>';
        return;
      }

      const yearLabelFontSize = Math.max(14, Math.min(32, Math.min(innerHeight * 0.045, innerWidth * 0.025)));
      const yearAxisFontSize = isSmallWindow
        ? 12
        : Math.max(16, Math.min(26, innerWidth * 0.03));

      const svg = d3.select(vizContainer)
        .append('svg')
        .attr('width', width)
        .attr('height', height);
      const defs = svg.append('defs');

      const chartGroup = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      const clipPaddingTop = Math.max(80, innerHeight * 0.2);
      const clipPaddingBottom = Math.max(30, innerHeight * 0.1);
      const chartClipId = `chart-clip-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      const clipPath = defs.append('clipPath')
        .attr('id', chartClipId);
      const clipRect = clipPath.append('rect')
        .attr('x', 0)
        .attr('y', -clipPaddingTop)
        .attr('width', 0)
        .attr('height', innerHeight + clipPaddingTop + clipPaddingBottom);
      const chartContent = chartGroup.append('g')
        .attr('class', 'chart-content')
        .attr('clip-path', `url(#${chartClipId})`);

      const titleOffsetX = Math.max(0, Math.min(24, innerWidth * 0.02));
      const titleOffsetY = Math.max(12, Math.min(36, innerHeight * 0.05));
      const subtitleSpacing = Math.max(isSmallWindow ? 28 : 40, Math.min(60, innerHeight * 0.08));

      const titleGroup = chartGroup.append('g')
        .attr('class', 'custom-title')
        .attr('transform', `translate(${titleOffsetX}, ${titleOffsetY})`)
        .style('opacity', showCustomTitle ? 1 : 0);

      const titleText = titleGroup.append('text')
        .attr('class', 'title-text')
        .attr('x', 0)
        .attr('y', 0)
        .attr('text-anchor', 'start');

      titleText.append('tspan')
        .attr('x', 0)
        .attr('dy', '1.2em')
        .text("The Open-Source");

      titleText.append('tspan')
        .attr('x', 0)
        .attr('dy', '1.1em')
        .text('AI Revolution');



      const x = d3.scaleUtc()
        .domain(d3.extent(data, d => d.date))
        .range([0, innerWidth]);

      const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.number)]).nice()
        .range([innerHeight, 0]);

      const stackGenerator = d3.stack().keys(stackKeys);
      const stackedSeries = stackGenerator(data);
      const bisectDate = d3.bisector(d => d.date).left;

      chartGroup.append('g')
        .attr('class', 'y-grid')
        .call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(''));

      if (VERTICAL_YEAR_COLORING === 1) {
        const gradientId = 'year-gradient';
        const gradient = defs.append('linearGradient')
          .attr('id', gradientId)
          .attr('x1', '0%')
          .attr('x2', '100%')
          .attr('y1', '0%')
          .attr('y2', '0%');

        const minDate = data[0].date;
        const maxDate = data[data.length - 1].date;
        const totalTime = maxDate - minDate;

        stackKeys.forEach(year => {
          const yearStart = new Date(Date.UTC(parseInt(year), 0, 1));
          const yearEnd = new Date(Date.UTC(parseInt(year) + 1, 0, 1));

          let start = yearStart < minDate ? minDate : yearStart;
          let end = yearEnd > maxDate ? maxDate : yearEnd;

          if (start < end) {
            const startPct = ((start - minDate) / totalTime) * 100;
            const endPct = ((end - minDate) / totalTime) * 100;
            const color = colorScale(year);

            gradient.append('stop').attr('offset', startPct + '%').attr('stop-color', color);
            gradient.append('stop').attr('offset', endPct + '%').attr('stop-color', color);
          }
        });

        const areaTotal = d3.area()
          .x(d => x(d.date))
          .y0(innerHeight)
          .y1(d => y(d.number))
          .curve(d3.curveMonotoneX);

        chartContent.append('path')
          .datum(data)
          .attr('class', 'total-area')
          .attr('fill', `url(#${gradientId})`)
          .attr('d', areaTotal)
          .attr('opacity', 0.9);

        stackKeys.forEach(year => {
          const yearStart = new Date(Date.UTC(parseInt(year), 0, 1));
          const yearEnd = new Date(Date.UTC(parseInt(year) + 1, 0, 1));

          let start = yearStart < minDate ? minDate : yearStart;
          let end = yearEnd > maxDate ? maxDate : yearEnd;

          if (start < end) {
          }

          if (yearStart > minDate && yearStart < maxDate) {
            chartContent.append('line')
              .attr('x1', x(yearStart))
              .attr('x2', x(yearStart))
              .attr('y1', 0)
              .attr('y2', innerHeight)
              .attr('stroke', 'rgba(15, 23, 42, 0.2)')
              .attr('stroke-dasharray', '4 4');
          }
        });

      } else {
        const area = d3.area()
          .x(d => x(d.data.date))
          .y0(d => y(d[0]))
          .y1(d => y(d[1]))
          .curve(d3.curveMonotoneX);

        chartContent.append('g')
          .attr('class', 'stacked-layers')
          .selectAll('.stacked-area-layer')
          .data(stackedSeries)
          .join('path')
          .attr('class', 'stacked-area-layer')
          .attr('fill', d => colorScale(d.key))
          .attr('d', area);
      }

      chartContent.append('path')
        .datum(data)
        .attr('class', 'total-line')
        .attr('d', d3.line()
          .x(d => x(d.date))
          .y(d => y(d.number))
          .curve(d3.curveMonotoneX)
        );

      let yearAxisLabelData = [];
      let yearAxisLabels = null;

      if (VERTICAL_YEAR_COLORING !== 1) {
        const labelX = innerWidth - 10;
        const labelData = stackedSeries.map(series => {
          const lastPoint = series[series.length - 1];
          const yLower = y(lastPoint[0]);
          const yUpper = y(lastPoint[1]);
          const areaHeight = Math.abs(yLower - yUpper);
          if (areaHeight < 24) {
            return null;
          }
          const yPos = Math.max(yUpper + 12, yLower - 6);
          return { key: series.key, x: labelX, y: yPos };
        }).filter(Boolean);

        chartContent.append('g')
          .attr('class', 'area-labels')
          .selectAll('text')
          .data(labelData)
          .join('text')
          .attr('class', 'area-label')
          .attr('x', d => d.x)
          .attr('y', d => d.y)
          .attr('text-anchor', 'end')
          .style('font-size', `${yearLabelFontSize}px`)
          .text(d => d.key);
      } else {
        const minDate = data[0].date;
        const maxDate = data[data.length - 1].date;

        yearAxisLabelData = stackKeys.map((year, idx) => {
          const yearStart = new Date(Date.UTC(parseInt(year), 0, 1));
          const yearEnd = new Date(Date.UTC(parseInt(year) + 1, 0, 1));

          let start = yearStart < minDate ? minDate : yearStart;
          let end = yearEnd > maxDate ? maxDate : yearEnd;

          if (start >= end) {
            return null;
          }
          const midTime = start.getTime() + (end.getTime() - start.getTime()) / 2;
          return {
            year,
            x: x(new Date(midTime)),
            startTime: start.getTime(),
            endTime: end.getTime(),
            isLastYear: idx === stackKeys.length - 1,
            revealed: false
          };
        }).filter(Boolean);
      }

      const xAxisTickCount = (VERTICAL_YEAR_COLORING === 1 || isSmallWindow)
        ? 0
        : Math.min(10, Math.floor(innerWidth / 90));
      const xAxis = d3.axisBottom(x)
        .ticks(xAxisTickCount)
        .tickFormat(VERTICAL_YEAR_COLORING === 1 ? (() => '') : formatAxisDate);

      chartGroup.append('g')
        .attr('class', 'x-axis')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(xAxis);

      const updateYearLabelVisibility = (pointerTime, immediate = false) => {
        if (!yearAxisLabels) return;
        yearAxisLabels.each(function (d) {
          if (!d) return;
          const labelSelection = d3.select(this);
          const withinEnd = d.isLastYear ? pointerTime <= d.endTime : pointerTime < d.endTime;
          if (!d.revealed && pointerTime >= d.startTime && withinEnd) {
            d.revealed = true;
            labelSelection.interrupt();
            if (immediate) {
              labelSelection.style('opacity', 1);
            } else {
              labelSelection
                .style('opacity', 0)
                .transition()
                .duration(400)
                .style('opacity', 1);
            }
          } else if (!d.revealed) {
            labelSelection.interrupt().style('opacity', 0);
          }
        });
      };

      const resetYearLabelVisibility = () => {
        if (!yearAxisLabels || !yearAxisLabelData.length) return;
        yearAxisLabelData.forEach(d => {
          if (d) {
            d.revealed = false;
          }
        });
        yearAxisLabels.interrupt().style('opacity', 0);
      };

      if (yearAxisLabelData.length) {
        const labelY = innerHeight + (isSmallWindow ? 18 : 30);
        const yearLabelsGroup = chartGroup.append('g')
          .attr('class', 'year-axis-labels');
        yearAxisLabels = yearLabelsGroup.selectAll('text')
          .data(yearAxisLabelData, d => d.year)
          .join('text')
          .attr('class', 'year-axis-label')
          .attr('x', d => d.x)
          .attr('y', labelY)
          .attr('text-anchor', 'middle')
          .style('font-size', `${yearAxisFontSize}px`)
          .style('opacity', 0)
          .text(d => d.year);
      }

      const yAxis = d3.axisLeft(y)
        .ticks(Math.min(5, Math.floor(innerHeight / 90)))
        .tickFormat(value => shortFormatter(value));

      chartGroup.append('g')
        .attr('class', 'y-axis')
        .call(yAxis);

      if (!isSmallWindow) {
        chartGroup.append('text')
          .attr('class', 'y-axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -margin.left + 24)
          .attr('text-anchor', 'middle')
          .text('Cumulative Number of AI Models on Hugging Face');
      }

      const pointerGroup = chartGroup.append('g')
        .attr('class', 'current-pointer')
        .style('opacity', 0);
      const pointerLine = pointerGroup.append('line')
        .attr('class', 'current-pointer-line')
        .attr('y1', 0)
        .attr('y2', innerHeight);
      const pointerDot = pointerGroup.append('circle')
        .attr('class', 'current-pointer-dot')
        .attr('r', 5);
      const pointerLabel = pointerGroup.append('text')
        .attr('class', 'current-pointer-label');

      const focusLine = chartGroup.append('line')
        .attr('class', 'focus-line')
        .attr('y1', 0)
        .attr('y2', innerHeight);

      const focusDot = chartGroup.append('circle')
        .attr('class', 'focus-dot')
        .attr('r', 4.5);

      const bringPointerElementsToFront = () => {
        pointerGroup.raise();
        focusLine.raise();
        focusDot.raise();
      };

      const startDateMs = data[0].date.getTime();
      const endDateMs = data[data.length - 1].date.getTime();
      const dateSpan = Math.max(1, endDateMs - startDateMs);

      const updatePointerPosition = (progress = 0, immediate = false) => {
        const safeProgress = Math.max(0, Math.min(1, progress || 0));
        const pointerTime = startDateMs + (dateSpan * safeProgress);
        let pointerDate = new Date(pointerTime);
        let pointerValue = data[0].number;

        if (data.length === 1) {
          pointerDate = data[0].date;
          pointerValue = data[0].number;
        } else {
          const index = Math.min(Math.max(bisectDate(data, pointerDate), 1), data.length - 1);
          const previous = data[index - 1];
          const next = data[index];
          const previousTime = previous.date.getTime();
          const nextTime = next.date.getTime();
          const segmentSpan = Math.max(1, nextTime - previousTime);
          const localProgress = Math.max(0, Math.min(1, (pointerTime - previousTime) / segmentSpan));
          pointerValue = previous.number + (next.number - previous.number) * localProgress;
          const clampedTime = Math.min(Math.max(pointerTime, previousTime), nextTime);
          pointerDate = new Date(clampedTime);
        }

        const xPos = x(pointerDate);
        const yPos = y(pointerValue);
        const labelY = Math.max(-clipPaddingTop + 10, yPos - 14);

        pointerLine
          .attr('x1', xPos)
          .attr('x2', xPos);
        pointerDot
          .attr('cx', xPos)
          .attr('cy', yPos);
        pointerLabel
          .attr('x', xPos)
          .attr('y', labelY)
          .text(numberFormatter(Math.round(pointerValue)));
        pointerGroup.style('opacity', 1);
        updateYearLabelVisibility(pointerTime, immediate);
      };

      const revealTargets = [];
      const registerRevealTarget = (selection, xPos, padding = 32) => {
        const threshold = Math.max(0, Math.min(innerWidth, xPos + padding));
        revealTargets.push({
          selection,
          threshold,
          visible: false
        });
        selection.style('opacity', 0);
      };

      const resetRevealTargets = () => {
        revealTargets.forEach(target => {
          target.visible = false;
          if (target.selection) {
            target.selection.interrupt().style('opacity', 0);
          }
        });
      };

      const updateRevealTargets = (progress = 0, immediate = false) => {
        if (!revealTargets.length) return;
        const revealWidth = innerWidth * Math.max(0, Math.min(1, progress));
        revealTargets.forEach(target => {
          if ((!target.visible && revealWidth >= target.threshold && target.selection) || (immediate && !target.visible)) {
            target.visible = true;
            target.selection.interrupt();
            if (immediate) {
              target.selection.style('opacity', 1);
            } else {
              target.selection.transition()
                .duration(600)
                .style('opacity', 1);
            }
          }
        });
      };

      if (KEY_MODELS && KEY_MODELS.length) {
        const keyModelsGroup = chartGroup.append('g')
          .attr('class', 'key-models')
          .style('overflow', 'visible');
        const logoSize = Math.max(30, Math.min(50, innerHeight * 0.06));
        const distanceFromLine = Math.max(15, Math.min(30, innerHeight * 0.04));
        const modelNameFontSize = Math.max(6, Math.min(12, innerHeight * 0.018));

        KEY_MODELS.forEach(modelInfo => {
          const mDate = parseDate(modelInfo.release_date);
          if (!mDate) return;

          const index = bisectDate(data, mDate);
          if (index < 0 || index >= data.length) return;
          const d = data[index];

          const xPos = x(mDate);
          const yPos = y(d.number);
          const logoYPosition = yPos - distanceFromLine - logoSize / 2;

          const modelWrapper = keyModelsGroup.append('g')
            .attr('class', 'key-model');

          const connectorLine = modelWrapper.append('line')
            .attr('x1', xPos)
            .attr('x2', xPos)
            .attr('y1', logoYPosition + logoSize / 2)
            .attr('y2', yPos)
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '2 2')
            .attr('opacity', 0.5);

          const anchorCircle = modelWrapper.append('circle')
            .attr('cx', xPos)
            .attr('cy', yPos)
            .attr('r', 4)
            .attr('fill', '#0f172a')
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 2);

          const modelGroup = modelWrapper.append('g')
            .attr('transform', `translate(${xPos}, ${logoYPosition})`);
          if (typeof modelGroup.raise === 'function') {
            modelGroup.raise();
          }

          const clipId = `clip-${modelInfo.model.replace(/\s+/g, '-')}-${Math.floor(Math.random() * 10000)}`;
          defs.append('clipPath')
            .attr('id', clipId)
            .append('circle')
            .attr('cx', logoSize / 2)
            .attr('cy', logoSize / 2)
            .attr('r', logoSize / 2);

          modelGroup.append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', logoSize / 2)
            .attr('fill', '#ffffff');

          modelGroup.append('image')
            .attr('href', modelInfo.logo)
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', logoSize)
            .attr('height', logoSize)
            .attr('transform', `translate(${-logoSize / 2}, ${-logoSize / 2})`)
            .attr('clip-path', `url(#${clipId})`)
            .style('cursor', 'pointer');

          modelGroup.append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', logoSize / 2)
            .attr('fill', 'none')
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 2);

          modelGroup.append('text')
            .attr('x', -logoSize / 2 - 8)
            .attr('y', 4)
            .attr('text-anchor', 'end')
            .style('font-size', `${modelNameFontSize}px`)
            .style('font-style', 'italic')
            .attr('font-weight', '600')
            .attr('fill', '#0f172a')
            .text(modelInfo.model);

          if (typeof connectorLine.lower === 'function') {
            connectorLine.lower();
          }
          if (typeof anchorCircle.lower === 'function') {
            anchorCircle.lower();
          }

          registerRevealTarget(modelWrapper, xPos, Math.max(logoSize, distanceFromLine * 2));
        });
      }

      if (KEY_MOMENTS && KEY_MOMENTS.length) {
        const momentsGroup = chartGroup.append('g')
          .attr('class', 'key-moments')
          .style('overflow', 'visible');
        const annotationYOffsetBase = Math.max(18, Math.min(45, innerHeight * 0.07));
        const annotationLift = Math.max(12, innerHeight * 0.02);
        const annotationYOffset = annotationYOffsetBase + annotationLift;
        const annotationXOffset = Math.max(10, Math.min(18, innerWidth * 0.02));
        const commentFontSize = isSmallWindow ? 'clamp(14px, 2.8vh, 24px)' : 'clamp(16px, 3.5vh, 30px)';
        const commentSubFontSize = isSmallWindow ? 'clamp(10px, 2.2vh, 16px)' : 'clamp(12px, 2vh, 18px)';
        const commentLineSpacing = isSmallWindow ? '1.1em' : '1.2em';
        const keyMomentRightPadding = isSmallWindow ? Math.max(12, Math.min(30, innerWidth * 0.05)) : 0;

        KEY_MOMENTS.forEach(moment => {
          const mDate = parseDate(moment.date);
          if (!mDate) return;

          const index = bisectDate(data, mDate);
          if (index < 0 || index >= data.length) return;
          const d = data[index];

          const xPos = x(mDate);
          const yPos = y(d.number);
          const milestoneLabel = getMomentLabel(moment).replace(/\s+/g, ' ').trim();
          if (!milestoneLabel) return;

          const momentWrapper = momentsGroup.append('g')
            .attr('class', 'key-moment');

          momentWrapper.append('line')
            .attr('x1', xPos)
            .attr('x2', xPos)
            .attr('y1', Math.max(0, yPos - annotationYOffset))
            .attr('y2', innerHeight)
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '2 2')
            .attr('opacity', 0.7);

          const annotationXBase = xPos - annotationXOffset;
          const cappedAnnotationX = Math.min(annotationXBase, innerWidth - keyMomentRightPadding);
          const labelY = Math.max(0, yPos - annotationYOffset);

          momentWrapper.append('line')
            .attr('x1', xPos)
            .attr('x2', cappedAnnotationX)
            .attr('y1', labelY)
            .attr('y2', labelY)
            .attr('stroke', '#0f172a')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '2 2')
            .attr('opacity', 0.8);

          const annotation = momentWrapper.append('g')
            .attr('transform', `translate(${cappedAnnotationX}, ${labelY})`);

          const annotationText = annotation.append('text')
            .attr('x', 0)
            .attr('y', 0)
            .attr('text-anchor', 'end')
            .attr('dominant-baseline', 'middle')
            .style('font-size', commentFontSize)
            .attr('font-weight', '700')
            .attr('fill', '#0f172a')
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 2)
            .attr('paint-order', 'stroke');

          annotationText.append('tspan')
            .attr('x', 0)
            .attr('dy', 0)
            .text(milestoneLabel);

          annotationText.append('tspan')
            .attr('x', 0)
            .attr('dy', commentLineSpacing)
            .style('font-size', commentSubFontSize)
            .attr('font-weight', '600')
            .text('Models');

          momentWrapper.append('circle')
            .attr('cx', xPos)
            .attr('cy', yPos)
            .attr('r', 8)
            .attr('fill', '#0f172a')
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 2);

          registerRevealTarget(momentWrapper, xPos, Math.max(24, annotationXOffset * 3));
        });
      }


      const overlay = chartGroup.append('rect')
        .attr('class', 'interaction-overlay')
        .attr('width', innerWidth)
        .attr('height', innerHeight)
        .attr('fill', 'transparent');
      bringPointerElementsToFront();

      overlay
        .on('mousemove', function (event) {
          const [mx, my] = d3.pointer(event, this);
          if (mx < 0 || mx > innerWidth || my < 0 || my > innerHeight) {
            focusLine.style('opacity', 0);
            focusDot.style('opacity', 0);
            hideTooltip();
            return;
          }
          const hoveredDate = x.invert(mx);
          const index = Math.min(Math.max(bisectDate(data, hoveredDate), 1), data.length - 1);
          const d0 = data[index - 1];
          const d1 = data[index];
          const d = hoveredDate - d0.date > d1.date - hoveredDate ? d1 : d0;

          const xPos = x(d.date);
          const yPos = y(d.number);

          focusLine
            .attr('x1', xPos)
            .attr('x2', xPos)
            .style('opacity', 1);

          focusDot
            .attr('cx', xPos)
            .attr('cy', yPos)
            .style('opacity', 1);

          const breakdownHtml = stackKeys.map(key => formatBreakdownRow(key, d[key], d.number)).join('');
          tooltipElement.innerHTML = `
        <div class="tooltip-title">${formatTooltipDate(d.date)}</div>
        <div class="tooltip-value">${numberFormatter(d.number)} models</div>
        <div class="tooltip-change">+${numberFormatter(d.dailyChange)} new</div>
        <div class="tooltip-breakdown">${breakdownHtml}</div>
      `;
          tooltipElement.style.opacity = 1;

          const tooltipWidth = tooltipElement.offsetWidth || 240;
          const tooltipHeight = tooltipElement.offsetHeight || 120;
          const containerWidth = vizContainer.clientWidth;
          const containerHeight = vizContainer.clientHeight;
          let left = margin.left + xPos + 16;
          if (left + tooltipWidth > containerWidth) {
            left = margin.left + xPos - tooltipWidth - 16;
          }
          left = Math.max(8, Math.min(containerWidth - tooltipWidth - 8, left));
          let top = margin.top + yPos - tooltipHeight - 12;
          if (top < 8) {
            top = margin.top + yPos + 12;
          }
          top = Math.max(8, Math.min(containerHeight - tooltipHeight - 8, top));
          tooltipElement.style.left = `${left}px`;
          tooltipElement.style.top = `${top}px`;
        })
        .on('mouseleave', function () {
          focusLine.style('opacity', 0);
          focusDot.style('opacity', 0);
          hideTooltip();
        });

      const completeAnimation = (immediate = false) => {
        updatePointerPosition(1, immediate);
        updateRevealTargets(1, immediate);
        pointerGroup.style('opacity', 1);
        skipAnimationHandler = null;
        if (restartButton) {
          setButtonMode(BUTTON_MODES.RESTART);
        }
      };

      const triggerAnimation = (force = false) => {
        if (!shouldAnimate && !force) {
          cancelActiveAnimation();
          resetRevealTargets();
          resetYearLabelVisibility();

          clipRect.attr('width', innerWidth);
          completeAnimation(true);
          return;
        }

        pointerGroup.style('opacity', 0);
        if (restartButton) {
          setButtonMode(BUTTON_MODES.SKIP);
        }
        updatePointerPosition(0);
        resetRevealTargets();
        resetYearLabelVisibility();
        skipAnimationHandler = () => {
          cancelActiveAnimation();
          clipRect.attr('width', innerWidth);
          completeAnimation();
        };
        startRevealAnimation({
          clipRect,
          targetWidth: innerWidth,
          onProgress: progress => {
            updatePointerPosition(progress);
            updateRevealTargets(progress);
            if (progress > 0) {
              pointerGroup.style('opacity', 1);
            }
          },
          onComplete: completeAnimation
        });
      };

      triggerAnimation();
      restartAnimationHandler = () => triggerAnimation(true);
    }

    function renderVisualizationForContainer() {
      if (!vizContainer || !preparedRows.length) {
        return;
      }
      const rect = vizContainer.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      renderVisualization(preparedRows, width, height);
    }

    function loadData() {
      if (vizContainer) {
        vizContainer.innerHTML = '<div class="loading-state">Loading daily model counts…</div>';
      }

      d3.csv(DATA_PATH, row => {
        const date = parseDate(row.date);
        const number = Number(row.number);
        if (!date || Number.isNaN(number)) {
          return null;
        }
        return { date, number };
      }).then(rows => {
        const validRows = rows.filter(Boolean);
        if (!validRows.length) {
          vizContainer.innerHTML = '<div class="empty-state">No data found in daily_models.csv.</div>';
          return;
        }
        const result = prepareStackRows(validRows);
        preparedRows = result.processed;
        stackKeys = result.keys;
        colorScale = d3.scaleOrdinal()
          .domain(stackKeys)
          .range(stackKeys.map((key, idx) => COLOR_PALETTE[idx % COLOR_PALETTE.length]));
        renderVisualizationForContainer();
      }).catch(error => {
        console.error(error);
        if (vizContainer) {
          vizContainer.innerHTML = '<div class="error-state">Unable to load the CSV data.</div>';
        }
      });
    }

    const updateContainerVisibility = function () {
      const vizGrid = document.querySelector('.viz-grid');
      const container1 = document.getElementById('container1');
      const container3 = document.getElementById('container3');
      const container4 = document.getElementById('container4');
      const isCompact = layoutMediaQuery && layoutMediaQuery.matches;

      if (isCompact) {
        if (container3) {
          container3.style.display = 'none';
          container3.style.gridRow = '';
          container3.style.gridColumn = '';
        }
        if (container4) {
          container4.style.display = 'none';
          container4.style.gridRow = '';
          container4.style.gridColumn = '';
        }
        if (vizGrid) {
          vizGrid.style.gridTemplateRows = '1fr';
          vizGrid.style.gridTemplateColumns = '1fr';
        }
        if (container1) {
          container1.style.gridRow = '1';
          container1.style.gridColumn = '1';
        }
        return;
      }

      if (container3) {
        container3.style.display = SHOW_CONTAINER_3 ? 'flex' : 'none';
        container3.style.gridRow = '';
        container3.style.gridColumn = '';
      }
      if (container4) {
        container4.style.display = SHOW_CONTAINER_4 ? 'flex' : 'none';
        container4.style.gridRow = '';
        container4.style.gridColumn = '';
      }

      const lowerRowVisible = (SHOW_CONTAINER_3 && container3) || (SHOW_CONTAINER_4 && container4);

      const gridRows = [];
      let currentRow = 1;
      const container1Height = 20 - (lowerRowVisible ? 1 : 0);
      gridRows.push(`${container1Height}fr`);

      if (lowerRowVisible) {
        gridRows.push('1fr');
        currentRow += 1;
        if (SHOW_CONTAINER_3 && container3) {
          container3.style.gridRow = currentRow.toString();
        }
        if (SHOW_CONTAINER_4 && container4) {
          container4.style.gridRow = currentRow.toString();
        }
        if (SHOW_CONTAINER_3 && !SHOW_CONTAINER_4 && container3) {
          container3.style.gridColumn = '1 / span 2';
        } else if (!SHOW_CONTAINER_3 && SHOW_CONTAINER_4 && container4) {
          container4.style.gridColumn = '1 / span 2';
        } else {
          if (container3) container3.style.gridColumn = '1';
          if (container4) container4.style.gridColumn = '2';
        }
      }

      if (vizGrid) {
        vizGrid.style.gridTemplateRows = gridRows.join(' ');
        vizGrid.style.gridTemplateColumns = '1fr 1fr';
      }
      if (container1) {
        container1.style.gridRow = '1';
        container1.style.gridColumn = '1 / span 2';
      }
    };

    const handleResize = function () {
      updateContainerVisibility();
      renderVisualizationForContainer();
    };

    let resizeTimer;

    window.addEventListener('resize', function () {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(handleResize, 120);
    });

    if (layoutMediaQuery && layoutMediaQuery.addEventListener) {
      layoutMediaQuery.addEventListener('change', handleResize);
    } else if (layoutMediaQuery && layoutMediaQuery.addListener) {
      layoutMediaQuery.addListener(handleResize);
    }

    updateContainerVisibility();

    if (typeof ResizeObserver !== 'undefined' && vizContainer) {
      const resizeObserver = new ResizeObserver(function () {
        renderVisualizationForContainer();
      });
      resizeObserver.observe(vizContainer);
    }

    document.addEventListener('keydown', function (event) {
      if (!event || typeof event.key !== 'string') return;
      if (event.key.toLowerCase() === 't') {
        showCustomTitle = !showCustomTitle;
        animateTitleVisibility(showCustomTitle, true);
        updateUrlBooleanParam('title', showCustomTitle);
      }
      if (event.key.toLowerCase() === 's') {
        if (typeof html2canvas === 'undefined') {
          console.warn('html2canvas library is not loaded');
          return;
        }
        html2canvas(document.body).then(canvas => {
          const image = canvas.toDataURL('image/jpeg', 0.9);
          const link = document.createElement('a');
          link.download = `viz-snapshot-${new Date().toISOString().slice(0, 10)}.jpg`;
          link.href = image;
          link.click();
        }).catch(err => {
          console.error('Screenshot failed:', err);
        });
      }
    });

    loadData();
  </script>
</body>

</html>