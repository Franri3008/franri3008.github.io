<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>HF Orgs Line Chart</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
html, body { height: 100%; }
body { margin: 0; overflow: hidden; background: #ffffff; color: #111; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif; height: 100vh; }
.viz-grid { display: grid; grid-template-rows: 17fr 3fr 1fr; grid-template-columns: 1fr 1fr; height: 100vh; width: 100%; box-sizing: border-box; padding-bottom: clamp(8px, 2vh, 18px); }
#container1 { grid-row: 1; grid-column: 1 / span 2; display: flex; overflow: hidden; min-height: 0; column-gap: 0; }
#container1 .y-axis-container { flex: 0 0 clamp(22px, 2.4vw, 32px); display: flex; align-items: center; justify-content: center; min-width: 0; border-right: 1px solid rgba(0,0,0,0.1); box-sizing: border-box; padding: 0 2px; }
#container1 .y-axis-label { writing-mode: vertical-rl; transform: rotate(180deg); text-align: center; font-weight: 600; font-size: clamp(11px, 1.2vw, 16px); color: #333; }
#container1 .chart-wrapper { flex: 1 1 auto; display: flex; min-width: 0; height: 100%; margin-left: -6px; }
#container1 .chart-wrapper-inner { flex: 1 1 auto; display: flex; min-width: 0; height: 100%; }

#container2 { grid-row: 2; grid-column: 1 / span 2; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; overflow: hidden; font-size: clamp(10px, 1.6vw, 16px); padding: 6px 10px; }
.metric-buttons { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 8px 10px; }
.metric-btn { padding: 6px 10px; border-radius: 8px; border: 1px solid #cfd2d7; background: #fff; font-weight: 600; cursor: pointer; user-select: none; transition: transform .08s ease, background .12s ease; }
.metric-btn:hover { transform: translateY(-1px); }
.metric-btn.active { background: #2756d3; color: #fff; border-color: #2756d3; }

.custom-legend { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: clamp(6px, 1.5vw, 14px); background: rgba(255, 255, 255, 0.9); padding: clamp(6px, 1.2vh, 10px) clamp(10px, 2vw, 16px); border-radius: clamp(6px, 1.2vw, 12px); box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: auto; max-width: 100%; max-height: 100%; font-size: 1em; }
.legend-item { display: flex; align-items: center; gap: 6px; cursor: pointer; transition: opacity .2s ease; font-weight: 600; color: #333; font-size: 0.75em; }
.legend-item.dim { opacity: 0.35; }
.legend-item:focus-visible { outline: 2px solid rgba(0,0,0,0.5); outline-offset: 2px; }
.legend-square { width: clamp(6px, 1.2vw, 10px); height: clamp(6px, 1.2vw, 10px); border-radius: 2px; box-shadow: 0 0 0 1px rgba(0,0,0,0.15) inset; }

#container3 { grid-row: 3; grid-column: 1; display: flex; align-items: center; justify-content: flex-start; padding: 0 20px; overflow: hidden; min-width: 0; }
#container4 { grid-row: 3; grid-column: 2; display: flex; align-items: center; justify-content: flex-end; padding: 0 20px; overflow: hidden; min-width: 0; }
#container4 a { height: 100%; display: flex; align-items: center; }

.source-text { font-size: clamp(10px, 1.6vw, 16px); font-weight: 600; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; font-style: normal; }
.source-text a { color: #2756d3; text-decoration: underline; cursor: pointer; font-style: normal; }
.source-text a:visited { color: #2756d3; }
.logo { height: 100%; width: auto; max-height: 100%; max-width: 100%; pointer-events: auto; object-fit: contain; }

@media (max-height: 500px) {
  .viz-grid { grid-template-rows: 1fr; grid-template-columns: 1fr; padding-bottom: 0; }
  #container1 { grid-row: 1; grid-column: 1; }
  #container2, #container3, #container4 { display: none !important; }
}

#viz { position: relative; width: 100%; height: 100%; min-width: 0; min-height: 0; display: flex; align-items: center; justify-content: center; }
#chart { display: block; width: 100%; height: 100%; }
#tooltip { position: absolute; background: #fff; border: 1px solid #d9d9df; border-radius: 6px; padding: 6px 8px; font-size: 12px; pointer-events: none; opacity: 0; box-shadow: 0 4px 14px rgba(0,0,0,0.08); transition: opacity .12s ease; }

.axis path, .axis line { stroke: #cfd2d7; }
.tick text { font-size: clamp(8px, 0.9vw, 11px); }
.grid line { stroke: #e6e8ef; }
.grid .domain { display: none; }
</style>
</head>
<body>
<div class="viz-layout" id="vizLayout">
  <div class="viz-grid">
    <div id="container1" class="container chart-container">
      <div class="y-axis-container">
        <div class="y-axis-label" id="yLabel">Cumulative value</div>
      </div>
      <div class="chart-wrapper">
        <div class="chart-wrapper-inner">
          <div id="viz">
            <svg id="chart"></svg>
            <div id="tooltip"></div>
          </div>
        </div>
      </div>
    </div>
    <div id="container2" class="container legend-container">
      <div class="custom-legend" id="legend"></div>
    </div>
    <div id="container3" class="container source-container">
      <div class="source-text">Source: <a href="https://huggingface.co/" target="_blank" rel="noopener">HuggingFace</a></div>
    </div>
    <div id="container4" class="container logo-container">
      <a href="https://aiworld.eu/" target="_blank" rel="noopener">
        <img src="https://aiworld.eu/logo-transparent.svg" class="logo" alt="AI World logo">
      </a>
    </div>
  </div>
</div>

<script>
const svg=d3.select("#chart");
const tooltip=d3.select("#tooltip");
const legendEl=d3.select("#legend");
const yLabelEl=document.getElementById("yLabel");
const vizLayout=document.getElementById("vizLayout");
const colorScale=d3.scaleOrdinal(d3.schemeTableau10);
const MONTH_LABELS=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
function getMonthLabel(month){
  if(Number.isInteger(month)&&month>=0&&month<MONTH_LABELS.length){
    return MONTH_LABELS[month];
  }
  if(Number.isFinite(month)){
    return `M${month+1}`;
  }
  return "M";
}
const METRICS=[
  {key:"repos_total",weekKey:"repos_week",label:"Repos"},
  {key:"likes_total",weekKey:"likes_week",label:"Likes"},
  {key:"downloads_total",weekKey:"downloads_week",label:"Downloads"},
  {key:"spaces_total",weekKey:"spaces_week",label:"Spaces"},
  {key:"datasets_total",weekKey:"datasets_week",label:"Datasets"},
  {key:"models_total",weekKey:"models_week",label:"Models"}
];
let currentMetric="repos_total";
let currentMode="cumulative";
let currentPeriod="weekly";
let currentScale="absolute";
let lastAbsoluteMode="cumulative";
let rawById=[];
let series=[];
let currentTimeline=[];
let active=new Map();
let currentRange={startIndex:0,endIndex:0};
let rangeDirty=false;
let sliderPanelEl=null;
let sliderInitialized=false;

function formatValue(v){
  if(!Number.isFinite(v)){ return "0"; }
  if(currentScale==="normalized"){
    return d3.format(".2~f")(v);
  }
  return d3.format(",")(v);
}

function formatRawValue(v){
  if(!Number.isFinite(v)){ return "0"; }
  return d3.format(",")(v);
}

function getPeriodLabel(){
  switch(currentPeriod){
    case "monthly": return "month";
    case "yearly": return "year";
    default: return "week";
  }
}

function getMetricDefinition(){
  return METRICS.find(m=>m.key===currentMetric)||METRICS[0];
}

function getActiveMetricKey(){
  const def=getMetricDefinition();
  return currentMode==="perWeek"&&def.weekKey?def.weekKey:def.key;
}

function getModeSuffix(){
  return currentMode==="perWeek"?`(per ${getPeriodLabel()})`:"(total)";
}

function getScaleSuffix(){
  return currentScale==="normalized"?" (indexed to start=1)":"";
}

function weekToDate(year, week){
  if(!Number.isFinite(+year)||!Number.isFinite(+week)){ return null; }
  const safeWeek=Math.max(1,Math.floor(week));
  const simple=new Date(Date.UTC(year,0,1));
  const day=simple.getUTCDay()||7;
  const isoWeekStart=new Date(simple);
  const diff=day<=4?1-day:8-day;
  isoWeekStart.setUTCDate(simple.getUTCDate()+diff+(safeWeek-1)*7);
  return isoWeekStart;
}

function addDays(date,days){
  if(!date){ return null; }
  const next=new Date(date.getTime());
  next.setUTCDate(next.getUTCDate()+days);
  return next;
}

function formatWeekLabel(date){
  if(!date){ return "Week"; }
  const month=getMonthLabel(date.getUTCMonth());
  const day=date.getUTCDate();
  const year=date.getUTCFullYear();
  return `Week of ${month} ${day}, ${year}`;
}

function getRelativePeriodLabel(index){
  const unit=currentPeriod==="monthly"?"Month":currentPeriod==="yearly"?"Year":"Week";
  return `${unit} ${index}`;
}

function orderToYearMonth(order){
  const year=Math.floor(order/12);
  const month=order-year*12;
  return { year, month };
}

function getPeriodInfo(entry, period){
  if(!entry){ return null; }
  const date=entry.__date||null;
  if(period==="monthly"){
    const year=Number.isFinite(+entry.year)?+entry.year:(date?date.getUTCFullYear():NaN);
    if(!Number.isFinite(year)){ return null; }
    const month=date?date.getUTCMonth():Math.max(0,Math.min(11,Math.floor((+entry.week-1)/4)));
    const order=year*12+month;
    return {
      order,
      label:`${getMonthLabel(month)} ${year}`,
      date:new Date(Date.UTC(year,month,1)),
      year,
      month
    };
  }
  if(period==="yearly"){
    const year=Number.isFinite(+entry.year)?+entry.year:NaN;
    if(!Number.isFinite(year)){ return null; }
    return {
      order:year,
      label:`${year}`,
      date:new Date(Date.UTC(year,0,1)),
      year,
      month:null
    };
  }
  const weekCount=Number.isFinite(+entry.week_count)?+entry.week_count:NaN;
  if(!Number.isFinite(weekCount)){ return null; }
  const label=date?formatWeekLabel(date):`Week ${weekCount}`;
  return {
    order:weekCount,
    label,
    date:date,
    year:date?date.getUTCFullYear():Number.isFinite(+entry.year)?+entry.year:undefined,
    month:date?date.getUTCMonth():undefined
  };
}

function createInfoFromOrder(order, period, baseInfo){
  if(period==="monthly"){
    const {year, month}=orderToYearMonth(order);
    return {
      order,
      label:`${getMonthLabel(month)} ${year}`,
      date:new Date(Date.UTC(year,month,1)),
      year,
      month
    };
  }
  if(period==="yearly"){
    const year=order;
    return {
      order,
      label:`${year}`,
      date:new Date(Date.UTC(year,0,1)),
      year,
      month:null
    };
  }
  let date=null;
  if(baseInfo&&baseInfo.date&&Number.isFinite(baseInfo.order)){
    const diff=order-baseInfo.order;
    date=addDays(baseInfo.date,diff*7);
  }
  return {
    order,
    label:date?formatWeekLabel(date):`Week ${order}`,
    date:date,
    year:date?date.getUTCFullYear():undefined,
    month:date?date.getUTCMonth():undefined
  };
}

function updateAxisLabel(){
  const def=getMetricDefinition();
  if(!def){ return; }
  const descriptors=[];
  if(currentScale!=="normalized"){
    descriptors.push(getModeSuffix());
  }
  const scaleSuffix=getScaleSuffix();
  if(scaleSuffix){
    descriptors.push(scaleSuffix);
  }
  const descriptorText=descriptors.join(" ").trim();
  const textParts=[def.label];
  if(descriptorText){
    textParts.push(descriptorText);
  }
  const labelText=textParts.join(" ");
  yLabelEl.textContent=labelText;
}

function buildLegend(ids){
  legendEl.selectAll("*").remove();
  const items=legendEl.selectAll(".legend-item").data(ids,d=>d).enter().append("div").attr("class","legend-item").attr("role","button").attr("tabindex",0).attr("aria-pressed","true");
  items.append("div").attr("class","legend-square").style("background",d=>colorScale(d));
  items.append("span").text(d=>d);
  function toggle(_,id){
    const curr=active.get(id);
    active.set(id,!curr);
    d3.select(this).classed("dim",!active.get(id)).attr("aria-pressed",active.get(id)?"true":"false");
    render();
  }
  items.on("click",toggle).on("keydown",function(e,id){ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggle.call(this,e,id); } });
}

function onConfigModeChange(mode){
  if(!mode||mode===currentMode||currentScale==="normalized"){ return; }
  lastAbsoluteMode=mode;
  currentMode=mode;
  if(window.ConfigTab&&typeof window.ConfigTab.setMode==="function"){
    window.ConfigTab.setMode(currentMode);
  }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function onConfigMetricChange(metric){
  if(!metric||metric===currentMetric){ return; }
  currentMetric=metric;
  if(window.ConfigTab&&typeof window.ConfigTab.setMetric==="function"){
    window.ConfigTab.setMetric(currentMetric);
  }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function onConfigPeriodChange(period){
  if(!period||period===currentPeriod){ return; }
  currentPeriod=period;
  if(window.ConfigTab&&typeof window.ConfigTab.setPeriod==="function"){
    window.ConfigTab.setPeriod(currentPeriod);
  }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function onConfigScaleChange(scale){
  if(!scale||scale===currentScale){ return; }
  currentScale=scale;
  if(currentScale==="normalized"){
    lastAbsoluteMode=currentMode;
    currentMode="cumulative";
    if(window.ConfigTab&&typeof window.ConfigTab.setMode==="function"){
      window.ConfigTab.setMode(currentMode);
    }
    if(window.ConfigTab&&typeof window.ConfigTab.setModeDisabled==="function"){
      window.ConfigTab.setModeDisabled(true);
    }
  }else{
    if(window.ConfigTab&&typeof window.ConfigTab.setModeDisabled==="function"){
      window.ConfigTab.setModeDisabled(false);
    }
    currentMode=lastAbsoluteMode||"cumulative";
    if(window.ConfigTab&&typeof window.ConfigTab.setMode==="function"){
      window.ConfigTab.setMode(currentMode);
    }
  }
  if(window.ConfigTab&&typeof window.ConfigTab.setScale==="function"){
    window.ConfigTab.setScale(currentScale);
  }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function getRangeUnit(){
  switch(currentPeriod){
    case "monthly": return "Month";
    case "yearly": return "Year";
    default: return "Week";
  }
}

function formatRangeLabelByIndex(idx){
  if(!Number.isInteger(idx)||idx<0||idx>=currentTimeline.length){
    return "N/A";
  }
  const info=currentTimeline[idx];
  if(!info){ return "N/A"; }
  if(currentScale==="normalized"){
    return getRelativePeriodLabel(info.relativeIndex);
  }
  return info.label||`Period ${info.coord}`;
}

function getClampedRangeIndices(){
  if(!currentTimeline.length){
    return {startIndex:0,endIndex:0,maxIndex:-1};
  }
  const maxIndex=currentTimeline.length-1;
  const rawStart=Number.isFinite(currentRange.startIndex)?currentRange.startIndex:0;
  const rawEnd=Number.isFinite(currentRange.endIndex)?currentRange.endIndex:maxIndex;
  const startIndex=Math.max(0,Math.min(rawStart,maxIndex));
  const endIndex=Math.max(startIndex,Math.min(rawEnd,maxIndex));
  return {startIndex,endIndex,maxIndex};
}

function syncRangeWithTimeline(){
  const length=currentTimeline.length;
  if(!length){
    currentRange.startIndex=0;
    currentRange.endIndex=0;
    if(sliderInitialized&&window.RangeSlider&&typeof window.RangeSlider.update==="function"){
      window.RangeSlider.update({
        min:0,
        max:0,
        start:0,
        end:0,
        getLabel:()=> "N/A",
        unitLabel:getRangeUnit()
      });
    }
    return;
  }
  const maxIndex=length-1;
  let start=rangeDirty?currentRange.startIndex:0;
  let end=rangeDirty?currentRange.endIndex:maxIndex;
  start=Math.max(0,Math.min(Number.isFinite(start)?start:0,maxIndex));
  end=Math.max(start,Math.min(Number.isFinite(end)?end:maxIndex,maxIndex));
  currentRange.startIndex=start;
  currentRange.endIndex=end;
  if(sliderInitialized&&window.RangeSlider&&typeof window.RangeSlider.update==="function"){
    window.RangeSlider.update({
      min:0,
      max:maxIndex,
      start,
      end,
      getLabel:formatRangeLabelByIndex,
      unitLabel:getRangeUnit()
    });
  }
}

function handleRangeChange(range){
  if(!range||!currentTimeline.length){ return; }
  const start=Number.isFinite(range.start)?Math.floor(range.start):0;
  const end=Number.isFinite(range.end)?Math.floor(range.end):0;
  const maxIndex=currentTimeline.length-1;
  const clampedStart=Math.max(0,Math.min(start,maxIndex));
  const clampedEnd=Math.max(clampedStart,Math.min(end,maxIndex));
  if(clampedStart===currentRange.startIndex&&clampedEnd===currentRange.endIndex){
    return;
  }
  rangeDirty=true;
  currentRange.startIndex=clampedStart;
  currentRange.endIndex=clampedEnd;
  if(tooltip){
    tooltip.style("opacity",0);
  }
  render();
}

async function loadSlider(){
  const container=document.getElementById("container2");
  if(!container||sliderInitialized){ return; }
  try{
    const response=await fetch("./slider.html");
    if(!response.ok){ throw new Error(`HTTP ${response.status}`); }
    const text=await response.text();
    const parser=new DOMParser();
    const doc=parser.parseFromString(text,"text/html");
    const styles=doc.querySelectorAll("style");
    styles.forEach(style=>{
      style.dataset.origin="range-slider";
      document.head.appendChild(style);
    });
    const panel=doc.querySelector("#sliderPanel");
    if(panel){
      const legend=document.getElementById("legend");
      if(legend&&legend.parentNode){
        legend.parentNode.insertBefore(panel,legend);
      }else{
        container.insertBefore(panel,container.firstChild);
      }
      sliderPanelEl=panel;
    }
    const scripts=doc.querySelectorAll("script");
    scripts.forEach(snippet=>{
      const script=document.createElement("script");
      if(snippet.src){
        script.src=snippet.src;
      }else{
        script.textContent=snippet.textContent;
      }
      script.dataset.origin="range-slider";
      document.body.appendChild(script);
    });
    if(window.RangeSlider&&typeof window.RangeSlider.init==="function"&&sliderPanelEl){
      window.RangeSlider.init({
        containerEl: sliderPanelEl,
        onChange: handleRangeChange
      });
      sliderInitialized=true;
      syncRangeWithTimeline();
    }
  }catch(err){
    console.error("Failed to load slider:",err);
  }
}

async function loadConfigTab(){
  if(!vizLayout){ return; }
  try{
    const response=await fetch("./tab.html");
    if(!response.ok){ throw new Error(`HTTP ${response.status}`); }
    const text=await response.text();
    const parser=new DOMParser();
    const doc=parser.parseFromString(text,"text/html");
    const styles=doc.querySelectorAll("style");
    styles.forEach(style=>{
      style.dataset.origin="config-tab";
      document.head.appendChild(style);
    });
    const panel=doc.querySelector("#configPanel");
    if(panel){
      vizLayout.appendChild(panel);
    }
    const scripts=doc.querySelectorAll("script");
    scripts.forEach(snippet=>{
      const script=document.createElement("script");
      if(snippet.src){
        script.src=snippet.src;
      }else{
        script.textContent=snippet.textContent;
      }
      script.dataset.origin="config-tab";
      document.body.appendChild(script);
    });
    if(window.ConfigTab&&typeof window.ConfigTab.init==="function"){
      window.ConfigTab.init({
        panelEl: document.getElementById("configPanel"),
        initialMode: currentMode,
        initialPeriod: currentPeriod,
        initialScale: currentScale,
        initialMetric: currentMetric,
        metrics: METRICS,
        onModeChange:onConfigModeChange,
        onPeriodChange:onConfigPeriodChange,
        onScaleChange:onConfigScaleChange,
        onMetricChange:onConfigMetricChange
      });
    }
  }catch(err){
    console.error("Failed to load config tab:",err);
  }
}

function load(){
  fetch("./data.json").then(r=>r.json()).then(json=>{
    const grouped=d3.groups(json,d=>d.id).map(([id,arr])=>{
      arr.sort((a,b)=>+a.week_count-+b.week_count);
      const enriched=arr.map(entry=>{
        const date=weekToDate(entry.year, entry.week);
        return {...entry, __date:date};
      });
      return {id, values:enriched};
    });
    rawById=grouped;
    const ids=rawById.map(s=>s.id);
    ids.forEach(id=>active.set(id,true));
    colorScale.domain(ids);
    updateAxisLabel();
    if(window.ConfigTab&&typeof window.ConfigTab.setMetrics==="function"){
      window.ConfigTab.setMetrics(METRICS,currentMetric);
    }
    if(window.ConfigTab&&typeof window.ConfigTab.setScale==="function"){
      window.ConfigTab.setScale(currentScale);
    }
    if(window.ConfigTab&&typeof window.ConfigTab.setModeDisabled==="function"){
      window.ConfigTab.setModeDisabled(currentScale==="normalized");
    }
    buildLegend(ids);
    buildSeriesFromRaw();
    render();
  }).catch(()=>{
    rawById=[];
    series=[];
    currentTimeline=[];
    syncRangeWithTimeline();
    render();
  });
}

function buildSeriesFromRaw(){
  const metricKey=getActiveMetricKey();
  const isPerPeriod=currentMode==="perWeek";
  const period=currentPeriod;
  const infoByOrder=new Map();
  rawById.forEach(({values})=>{
    values.forEach(entry=>{
      const info=getPeriodInfo(entry,period);
      if(!info){ return; }
      const existing=infoByOrder.get(info.order);
      if(existing){
        if(!existing.date&&info.date){
          infoByOrder.set(info.order,{...existing,date:info.date});
        }
      }else{
        infoByOrder.set(info.order,{...info});
      }
    });
  });
  const sortedInfos=Array.from(infoByOrder.values()).sort((a,b)=>a.order-b.order);
  if(!sortedInfos.length){
    series=[];
    currentTimeline=[];
    return;
  }
  const baseInfo=sortedInfos.find(info=>info.date)||sortedInfos[0];
  const getInfoForOrder=order=>{
    const cached=infoByOrder.get(order);
    let info=cached?{...cached}:createInfoFromOrder(order,period,baseInfo);
    if(period==="weekly"&&!info.date&&baseInfo&&baseInfo.date){
      const diff=order-baseInfo.order;
      info.date=addDays(baseInfo.date,diff*7);
    }
    if(period==="monthly"&&(!Number.isInteger(info.month)||!Number.isInteger(info.year))){
      const {year,month}=orderToYearMonth(order);
      info.month=month;
      info.year=year;
    }
    if(period==="weekly"&&info.date){
      info.year=info.date.getUTCFullYear();
      info.month=info.date.getUTCMonth();
    }
    if(!info.label){
      if(period==="monthly"){
        const {year,month}=orderToYearMonth(order);
        info.label=`${getMonthLabel(month)} ${year}`;
      }else if(period==="yearly"){
        info.label=`${order}`;
      }else if(info.date){
        info.label=formatWeekLabel(info.date);
      }else{
        info.label=`Week ${order}`;
      }
    }
    return info;
  };

  if(currentScale==="normalized"){
    let maxRelativeIndex=-1;
    series=rawById.map(({id, values})=>{
      const aggregated=new Map();
      let minOrder=Infinity;
      let maxOrder=-Infinity;
      values.forEach(entry=>{
        const info=getPeriodInfo(entry,period);
        if(!info){ return; }
        const order=info.order;
        const target=aggregated.get(order)||{sum:0,last:null,info:null};
        if(isPerPeriod){
          target.sum+=+entry[metricKey]||0;
        }else{
          target.last=+entry[metricKey]||0;
        }
        if(!target.info||(!target.info.date&&info.date)){
          target.info=info;
        }
        aggregated.set(order,target);
        if(order<minOrder){ minOrder=order; }
        if(order>maxOrder){ maxOrder=order; }
      });
      if(!aggregated.size||!Number.isFinite(minOrder)||!Number.isFinite(maxOrder)){
        return {id, values:[]};
      }
      const result=[];
      let running=0;
      let relativeIndex=0;
      for(let order=minOrder; order<=maxOrder; order++){
        const dataPoint=aggregated.get(order);
        let info=null;
        if(dataPoint&&dataPoint.info){
          info={...dataPoint.info};
        }else{
          info=getInfoForOrder(order);
        }
        let rawValue=0;
        if(isPerPeriod){
          rawValue=dataPoint?dataPoint.sum:0;
        }else{
          if(dataPoint&&typeof dataPoint.last==="number"){
            running=dataPoint.last;
          }
          rawValue=running;
        }
        const relativeLabel=getRelativePeriodLabel(relativeIndex);
        result.push({
          w:relativeIndex,
          rawValue,
          value:rawValue,
          label:info.label,
          actualLabel:info.label,
          relativeLabel,
          order,
          date:info.date,
          relativeIndex,
          absoluteIndex:order
        });
        relativeIndex++;
      }
      if(result.length){
        const baselinePoint=result.find(pt=>Number.isFinite(pt.rawValue)&&Math.abs(pt.rawValue)>0);
        const baseline=baselinePoint?baselinePoint.rawValue:null;
        const divisor=baseline&&Math.abs(baseline)>0?baseline:null;
        result.forEach(pt=>{
          pt.value=divisor?pt.rawValue/divisor:0;
        });
        maxRelativeIndex=Math.max(maxRelativeIndex,result.length-1);
      }
      return {id, values:result};
    });
    currentTimeline=maxRelativeIndex>=0?Array.from({length:maxRelativeIndex+1},(_,idx)=>({
      order:idx,
      label:getRelativePeriodLabel(idx),
      date:null,
      year:null,
      month:null,
      relativeIndex:idx,
      absoluteIndex:idx,
      coord:idx
    })):[];
    syncRangeWithTimeline();
    return;
  }

  const minOrder=sortedInfos[0].order;
  const maxOrder=sortedInfos[sortedInfos.length-1].order;
  const timeline=[];
  for(let order=minOrder,index=1; order<=maxOrder; order++, index++){
    let info=infoByOrder.get(order);
    if(info){
      info={...info};
    }else{
      info=createInfoFromOrder(order,period,baseInfo);
    }
    if(period==="weekly"&&!info.date&&baseInfo&&baseInfo.date){
      const diff=order-baseInfo.order;
      info.date=addDays(baseInfo.date,diff*7);
    }
    if(!info.label){
      if(period==="monthly"){
        const {year,month}=orderToYearMonth(order);
        info.label=`${getMonthLabel(month)} ${year}`;
      }else if(period==="yearly"){
        info.label=`${order}`;
      }else if(info.date){
        info.label=formatWeekLabel(info.date);
      }else{
        info.label=`Week ${order}`;
      }
    }
    if(period==="monthly"&&(!Number.isInteger(info.month)||!Number.isInteger(info.year))){
      const {year,month}=orderToYearMonth(order);
      info.month=month;
      info.year=year;
    }
    if(period==="weekly"&&info.date){
      info.year=info.date.getUTCFullYear();
      info.month=info.date.getUTCMonth();
    }
    info.index=index;
    timeline.push(info);
  }
  timeline.forEach((info,idx)=>{
    info.relativeIndex=idx;
    info.absoluteIndex=info.index;
    info.coord=info.index;
  });
  currentTimeline=timeline;
  series=rawById.map(({id, values})=>{
    const aggregated=new Map();
    values.forEach(entry=>{
      const info=getPeriodInfo(entry,period);
      if(!info){ return; }
      const target=aggregated.get(info.order)||{sum:0,last:null};
      if(isPerPeriod){
        target.sum+=+entry[metricKey]||0;
      }else{
        target.last=+entry[metricKey]||0;
      }
      aggregated.set(info.order,target);
    });
    const result=[];
    let running=0;
    currentTimeline.forEach(info=>{
      const dataPoint=aggregated.get(info.order);
      let rawValue=0;
      if(isPerPeriod){
        rawValue=dataPoint?dataPoint.sum:0;
      }else{
        if(dataPoint&&typeof dataPoint.last==="number"){
          running=dataPoint.last;
        }
        rawValue=running;
      }
      result.push({
        w:info.coord,
        rawValue,
        value:rawValue,
        label:info.label,
        actualLabel:info.label,
        relativeLabel:null,
        order:info.order,
        date:info.date,
        relativeIndex:info.relativeIndex,
        absoluteIndex:info.absoluteIndex
      });
    });
    return {id, values:result};
  });
  syncRangeWithTimeline();
}

function measureLabelWidth(labels,fontSize){
  const g=svg.append("g").attr("opacity",0).attr("transform","translate(-9999,-9999)");
  const t=g.selectAll("text").data(labels).enter().append("text").style("font-size",fontSize+"px").text(d=>d);
  let w=0;
  t.each(function(){ w=Math.max(w,this.getComputedTextLength()); });
  g.remove();
  return w;
}

function getTimelineInfoByCoord(coord){
  if(!currentTimeline.length||!Number.isFinite(coord)){ return null; }
  if(currentScale==="normalized"){
    const idx=Math.round(coord);
    if(idx<0||idx>=currentTimeline.length){ return null; }
    return currentTimeline[idx];
  }
  const idx=Math.round(coord)-1;
  if(idx<0||idx>=currentTimeline.length){ return null; }
  return currentTimeline[idx];
}

function formatTimelineTick(value){
  if(!currentTimeline.length){ return ""; }
  const info=getTimelineInfoByCoord(value);
  if(!info){ return ""; }
  if(currentScale==="normalized"){
    return getRelativePeriodLabel(info.relativeIndex);
  }
  if(currentPeriod==="weekly"){
    return `W${info.order}`;
  }
  if(currentPeriod==="monthly"){
    const month=Number.isInteger(info.month)?getMonthLabel(info.month):null;
    const year=info.year;
    if(month&&year){
      return `${month} ${String(year).slice(-2)}`;
    }
    return info.label||"";
  }
  if(currentPeriod==="yearly"){
    return `${info.year||info.order}`;
  }
  return info.label||`${Math.round(value)}`;
}

function getPointLabel(point){
  if(!point){ return ""; }
  if(currentScale==="normalized"){
    if(Number.isFinite(point.relativeIndex)){
      return point.relativeLabel||getRelativePeriodLabel(point.relativeIndex);
    }
    const infoNorm=getTimelineInfoByCoord(point.w);
    return infoNorm?getRelativePeriodLabel(infoNorm.relativeIndex):"";
  }
  const info=getTimelineInfoByCoord(point.w);
  if(!info){ return ""; }
  return info.label||`Period ${point.w}`;
}

function createTooltipHtml(point,labelText,metricDef){
  const metricName=metricDef?metricDef.label:"";
  const modeLabel=currentScale==="normalized"?"":getModeSuffix();
  const scaleLabel=currentScale==="normalized"?"":getScaleSuffix();
  const lines=[];
  lines.push(`<strong>${point.id}</strong>`);
  lines.push(labelText);
  if(currentScale==="normalized"){
    const actual=point.actualLabel||point.label;
    if(actual){
      lines.push(`Actual period: ${actual}`);
    }
  }else{
    const info=getTimelineInfoByCoord(point.w);
    if(info&&info.label&&info.label!==labelText){
      lines.push(info.label);
    }
  }
  if(currentScale==="normalized"){
    const indexValue=formatValue(point.value);
    lines.push(`Index: ${indexValue}`);
    const actualSuffix=[metricName].filter(Boolean).join(" ").trim();
    const actualValue=formatRawValue(point.rawValue??point.value);
    lines.push(`Actual: ${actualValue}${actualSuffix?` ${actualSuffix}`:""}`);
  }else{
    let descriptor=[metricName,modeLabel,scaleLabel].filter(Boolean).join(" ").trim();
    descriptor=descriptor?` ${descriptor}`:"";
    const valueText=`${formatValue(point.value)}${descriptor}`.trim();
    lines.push(valueText);
  }
  return lines.join("<br>");
}

function render(){
  const viz=document.getElementById("viz");
  const rect=viz.getBoundingClientRect();
  const fullW=rect.width;
  const fullH=rect.height;
  const axisContainer=document.querySelector("#container1 .y-axis-container");
  const axisContainerWidth=axisContainer?axisContainer.getBoundingClientRect().width:24;
  svg.attr("width",fullW).attr("height",fullH);
  const tickFont=Math.max(9,Math.min(13,fullW/110));
  if(!currentTimeline.length){
    svg.selectAll("*").remove();
    return;
  }
  const {startIndex,endIndex}=getClampedRangeIndices();
  const timelineSlice=currentTimeline.filter(info=>info.relativeIndex>=startIndex&&info.relativeIndex<=endIndex);
  if(!timelineSlice.length){
    svg.selectAll("*").remove();
    return;
  }
  const rangeMinCoord=timelineSlice[0].coord;
  const rangeMaxCoord=timelineSlice[timelineSlice.length-1].coord;
  const singlePoint=rangeMinCoord===rangeMaxCoord;
  const domainMin=singlePoint?rangeMinCoord-0.5:rangeMinCoord;
  const domainMax=singlePoint?rangeMaxCoord+0.5:rangeMaxCoord;

  const filteredSeries=series.map(s=>({
    id:s.id,
    values:s.values.filter(v=>v.relativeIndex>=startIndex&&v.relativeIndex<=endIndex)
  }));
  const activeSeries=filteredSeries.filter(s=>active.get(s.id));
  const visibleSeries=activeSeries.filter(s=>s.values.length);
  const seriesForScale=visibleSeries.length?visibleSeries:activeSeries.length?activeSeries:filteredSeries;
  let yMax=d3.max(seriesForScale, s=>d3.max(s.values,v=>v.value));
  if(!Number.isFinite(yMax)||yMax<=0){
    yMax=1;
  }
  if(currentScale==="normalized"){
    yMax=Math.max(yMax,1);
  }
  const tmpY=d3.scaleLinear().domain([0,yMax]).range([100,0]);
  const yTicks=tmpY.ticks(Math.max(3,Math.round(fullH*0.6/60))).map(formatValue);
  const yLabelW=measureLabelWidth(yTicks,tickFont);

  const margin={
    top:Math.max(10,fullH*0.04),
    right:Math.max(16,fullW*0.05),
    bottom:Math.max(22,fullH*0.08),
    left:Math.max(8,axisContainerWidth+yLabelW+6)
  };

  const width=Math.max(0,fullW-margin.left-margin.right);
  const height=Math.max(0,fullH-margin.top-margin.bottom);
  const gRoot=svg.selectAll("g.root").data([null]).join("g").attr("class","root").attr("transform",`translate(${margin.left},${margin.top})`);
  if(width<=0||height<=0){ return; }

  const x=d3.scaleLinear().domain([domainMin,domainMax]).range([0,width]);
  const y=d3.scaleLinear().domain([0,yMax]).range([height,0]).nice();
  const xTickCount=Math.max(3,Math.round(width/90));
  const yTickCount=Math.max(3,Math.round(height/60));
  let xTicks=d3.ticks(rangeMinCoord,rangeMaxCoord,xTickCount);
  xTicks=xTicks.map(val=>Math.round(val));
  const allowedCoords=new Set(timelineSlice.map(info=>info.coord));
  xTicks=Array.from(new Set(xTicks)).filter(t=>allowedCoords.has(t));
  if(singlePoint){
    xTicks=[rangeMinCoord];
  }else{
    if(!xTicks.includes(rangeMinCoord)){ xTicks.unshift(rangeMinCoord); }
    if(!xTicks.includes(rangeMaxCoord)){ xTicks.push(rangeMaxCoord); }
  }
  xTicks.sort((a,b)=>a-b);

  const gridX=gRoot.selectAll("g.grid-x").data([null]).join("g").attr("class","grid grid-x").attr("transform",`translate(0,${height})`);
  gridX.call(d3.axisBottom(x).tickValues(xTicks).tickSize(-height).tickFormat(""));
  const gridY=gRoot.selectAll("g.grid-y").data([null]).join("g").attr("class","grid grid-y");
  gridY.call(d3.axisLeft(y).ticks(yTickCount).tickSize(-width).tickFormat(""));
  gridX.select(".domain").remove();
  gridY.select(".domain").remove();

  const xAxis=gRoot.selectAll("g.x").data([null]).join("g").attr("class","axis x").attr("transform",`translate(0,${height})`);
  const yAxis=gRoot.selectAll("g.y").data([null]).join("g").attr("class","axis y");
  xAxis.call(d3.axisBottom(x).tickValues(xTicks).tickFormat(formatTimelineTick));
  yAxis.call(d3.axisLeft(y).ticks(yTickCount).tickPadding(2));
  svg.selectAll(".axis text").style("font-size",tickFont+"px");

  const lineW=2*Math.max(1.25,Math.min(2.25,width/600));
  const lineGen=d3.line().x(d=>x(d.w)).y(d=>y(d.value));

  gRoot.selectAll("path.series").data(visibleSeries,d=>d.id).join(
    enter=>enter.append("path").attr("class","series").attr("fill","none").attr("stroke",d=>colorScale(d.id)).attr("stroke-width",lineW).attr("d",d=>lineGen(d.values)),
    update=>update.attr("stroke-width",lineW).attr("d",d=>lineGen(d.values)),
    exit=>exit.remove()
  );

  const groups=gRoot.selectAll("g.dots").data(visibleSeries,d=>d.id).join(
    enter=>enter.append("g").attr("class","dots"),
    update=>update,
    exit=>exit.remove()
  );

  groups.each(function(s){
    const baseR=Math.max(2,Math.min(2,width/500));
    const data=s.values.map((v,i)=>({
      id:s.id,
      w:v.w,
      value:v.value,
      rawValue:v.rawValue,
      label:v.label,
      actualLabel:v.actualLabel,
      relativeLabel:v.relativeLabel,
      relativeIndex:v.relativeIndex,
      order:v.order,
      date:v.date,
      isFinal:i===s.values.length-1
    }));
    const sel=d3.select(this).selectAll("circle.dot").data(data,d=>`${d.id}-${d.w}`);
    sel.join(
      enter=>enter.append("circle").attr("class","dot").attr("r",d=>d.isFinal?baseR*5:baseR).attr("cx",d=>x(d.w)).attr("cy",d=>y(d.value)).attr("fill",d=>d.isFinal?"#ffffff":colorScale(s.id)).attr("stroke",colorScale(s.id)).attr("stroke-width",1).style("pointer-events","all"),
      update=>update.attr("r",d=>d.isFinal?baseR*5:baseR).attr("cx",d=>x(d.w)).attr("cy",d=>y(d.value)).attr("fill",d=>d.isFinal?"#ffffff":colorScale(s.id)).attr("stroke",colorScale(s.id)),
      exit=>exit.remove()
    ).on("pointerenter",function(event,d){
      const cx=+this.getAttribute("cx")+margin.left;
      const cy=+this.getAttribute("cy")+margin.top;
      d3.select(this).raise().transition().duration(160).attr("r",d.isFinal?baseR*6:baseR*3);
      const metricDef=getMetricDefinition();
      const labelText=getPointLabel(d);
      const tooltipHtml=createTooltipHtml(d,labelText,metricDef);
      tooltip.style("opacity",1).style("left",cx+10+"px").style("top",cy-10+"px").html(tooltipHtml);
    }).on("pointermove",function(){
      const cx=+this.getAttribute("cx")+margin.left;
      const cy=+this.getAttribute("cy")+margin.top;
      tooltip.style("left",cx+10+"px").style("top",cy-10+"px");
    }).on("pointerleave",function(event,d){
      d3.select(this).transition().duration(160).attr("r",d.isFinal?baseR*5:baseR);
      tooltip.style("opacity",0);
    });
  });

  svg.selectAll("rect.pointer-capture").remove();
}

loadConfigTab();
loadSlider();
load();
window.addEventListener("resize",function(){ render(); });
const vizEl=document.getElementById("viz");
if(typeof ResizeObserver!=="undefined"&&vizEl){
  const chartObserver=new ResizeObserver(function(){ render(); });
  chartObserver.observe(vizEl);
}
</script>
</body>
</html>
