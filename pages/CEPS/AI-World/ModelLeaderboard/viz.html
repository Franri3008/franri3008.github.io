<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Leaderboards Ranking</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: #f9fafc;
      color: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif;
      height: 100vh;
    }

    .viz-grid {
      display: grid;
      grid-template-rows: auto 1fr auto;
      grid-template-columns: 1fr auto;
      height: 100vh;
      width: 100vw;
      box-sizing: border-box;
      padding-bottom: 8px;
    }

    #container1 {
      grid-row: 2;
      grid-column: 1 / span 2;
      display: flex;
      overflow: hidden;
      align-items: center;
      justify-content: center;
    }

    #footnote-container {
      grid-row: 3;
      grid-column: 1 / span 2;
      background: #f9fafc;
      padding: 8px 16px;
      font-style: italic;
      font-size: clamp(10px, 1.4vw, 13px);
      color: #666;
      text-align: right;
      display: none;
    }

    #container1 .chart-wrapper {
      flex: 1 1 auto;
      display: flex;
      min-width: 0;
      height: 100%;
    }

    #container1 .chart-wrapper-inner {
      flex: 1 1 auto;
      display: flex;
      min-width: 0;
      height: 100%;
    }

    #chart {
      display: block;
      width: 100%;
      height: 100%;
    }

    #container2 {
      grid-row: 1;
      grid-column: 1 / span 2;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      padding: 12px 20px;
      position: relative;
    }

    #container3 {
      display: none;
    }

    #container4 {
      display: none;
    }

    .tabs-container {
      display: flex;
      align-items: center;
      gap: clamp(24px, 3vw, 40px);
      position: relative;
    }

    .tab {
      font-size: clamp(13px, 1.6vw, 16px);
      font-weight: 600;
      color: #999;
      white-space: nowrap;
      cursor: pointer;
      padding: 8px 0;
      transition: color 0.2s ease;
      user-select: none;
      position: relative;
    }

    .tab:hover {
      color: #666;
    }

    .tab.active {
      color: #2756d3;
    }

    .tab-indicator {
      position: absolute;
      bottom: 0;
      height: 3px;
      background: #2756d3;
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 0;
    }

    .tab-indicator.active {
      opacity: 1;
    }

    .tab-separator {
      width: 1px;
      height: 20px;
      background: #d0d0d7;
      margin: 0 clamp(16px, 2vw, 24px);
    }

    .answer-section {
      display: flex;
      align-items: center;
      gap: clamp(8px, 1vw, 12px);
      opacity: 1;
      max-width: 500px;
      transition: opacity 0.3s ease, max-width 0.3s ease, margin 0.3s ease;
      overflow: hidden;
    }

    .answer-section.hidden {
      opacity: 0;
      max-width: 0;
      margin: 0;
    }

    .answer-text {
      font-size: clamp(12px, 1.6vw, 16px);
      font-weight: 700;
      color: #1a73e8;
      white-space: nowrap;
      padding: clamp(6px, 1vw, 10px) clamp(12px, 1.5vw, 16px);
      background: #e8f3ff;
      border-radius: 1px;
    }

    .source-text {
      font-size: clamp(10px, 1.6vw, 16px);
      font-weight: 600;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      font-style: normal;
    }

    .source-text a {
      color: #2756d3;
      text-decoration: underline;
      cursor: pointer;
      font-style: normal;
    }

    .source-text a:visited {
      color: #2756d3;
    }

    .logo-container .logo {
      height: 100%;
      width: auto;
      max-height: 100%;
      max-width: 100%;
      pointer-events: auto;
      object-fit: contain;
    }

    #tooltip {
      position: absolute;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      border-radius: 6px;
      font-size: 13px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
    }

    @media (max-height:500px),
    (max-width:640px) {
      .viz-grid {
        grid-template-rows: 1fr;
        grid-template-columns: 1fr;
        padding-bottom: 0px;
      }

      #container2,
      #container3,
      #container4,
      #footnote-container {
        display: none !important;
      }

      #container1 {
        grid-row: 1;
        grid-column: 1;
      }
    }
  </style>
</head>

<body>
  <div class="viz-grid">
    <div id="container2" class="container control-container">
      <div class="tabs-container">
        <div class="tab active" data-question="ALL">AIW Overall</div>
        <div class="tab-separator"></div>
        <div class="tab" data-question="LMArena">LMArena</div>
        <div class="tab" data-question="Artificial Analysis">Artificial Analysis</div>
        <div class="tab" data-question="LiveBench">LiveBench</div>
        <div class="tab-indicator"></div>
      </div>
    </div>
    <div id="container1" class="container chart-container">
      <div class="chart-wrapper">
        <div class="chart-wrapper-inner">
          <svg id="chart"></svg>
        </div>
      </div>
    </div>
    <div id="container3" class="container source-container">
      <div class="source-text">Source: <a href="https://aiworld.eu" target="_blank">AI World</a></div>
    </div>
    <div id="container4" class="container logo-container">
      <a href="https://aiworld.eu/" target="_blank" rel="noopener">
        <img src="https://aiworld.eu/logo-transparent.svg" class="logo" alt="AI World logo">
      </a>
    </div>
    <div id="footnote-container">
      Scores are normalized from three benchmarks (LMArena, Artificial Analysis, LiveBench). If a model is missing one
      benchmark, it is estimated as the average of the other two.
    </div>
  </div>
  <div id="tooltip"></div>
  <script>
    const tooltip = d3.select("#tooltip");
    let rawData = [];
    let questions = [];
    let modelIcons = {};
    let modelColors = {};
    let questionAnswers = {};
    let active = { question: 'ALL' };
    let displayLimit = 30;
    let styleMode = 0;
    let highlightMode = null;
    let highlightPaused = false;
    let highlightPauseTimeout = null;
    function parseNum(v) { if (v == null) { return 0; } const s = String(v).replace(/,/g, '.'); const n = parseFloat(s); return isNaN(n) ? 0 : n; }
    function hexToRgb(hex) { const s = hex.replace('#', ''); const v = s.length === 3 ? s.split('').map(ch => ch + ch).join('') : s; const n = parseInt(v, 16); return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 }; }
    function rgbToHex(r, g, b) { const toHex = x => x.toString(16).padStart(2, '0'); return '#' + toHex(r) + toHex(g) + toHex(b); }
    function lighten(hex, amt) { if (!hex) { return null; } const { r, g, b } = hexToRgb(hex); const lr = Math.min(255, Math.round(r + (255 - r) * amt)); const lg = Math.min(255, Math.round(g + (255 - g) * amt)); const lb = Math.min(255, Math.round(b + (255 - b) * amt)); return rgbToHex(lr, lg, lb); }
    function load() {
      const params = new URLSearchParams(window.location.search);
      const snapshotParam = params.get('snapshot');
      const csvPath = snapshotParam ? `data/snapshot/${snapshotParam}.csv` : 'data/processed.csv';
      Promise.all([
        d3.dsv(";", csvPath),
        d3.json("config/models.json")
      ]).then(([data, modelsData]) => {
        rawData = data;

        const idToColor = {};
        modelsData.forEach(model => {
          idToColor[model.id] = model.color;
        });

        rawData.forEach(d => {
          const model = String(d.model || '').trim();
          const name = String(d.name || '').trim();
          const logo = String(d.logo || '').trim();
          d.displayName = name || model;
          if (logo) {
            modelIcons[model] = `logos/${logo}.png`;
            if (idToColor[logo]) {
              modelColors[model] = idToColor[logo];
            }
          }
        });

        questions = ['ALL', 'LMArena', 'Artificial Analysis', 'LiveBench'];
        active.question = 'ALL';

        const params = new URLSearchParams(window.location.search);
        const sourceParam = params.get('source');
        if (sourceParam) {
          const map = { 'aiw': 'ALL', 'llma': 'LMArena', 'aa': 'Artificial Analysis', 'lb': 'LiveBench' };
          const mapped = map[sourceParam.toLowerCase()];
          if (mapped) {
            active.question = mapped;
            document.querySelectorAll('.tab').forEach(t => {
              if (t.getAttribute('data-question') === mapped) {
                t.classList.add('active');
              } else {
                t.classList.remove('active');
              }
            });
          }
        }

        const topParam = params.get('top');
        if (topParam) {
          const val = parseInt(topParam, 10);
          if (!isNaN(val) && val > 0) {
            displayLimit = val;
          }
        }

        const styleParam = params.get('style');
        if (styleParam) {
          const s = parseInt(styleParam, 10);
          if (s === 1) styleMode = 1;
        }

        const highlightParam = params.get('highlight');
        if (highlightParam) {
          highlightMode = highlightParam;
          document.addEventListener('mousemove', pauseHighlight);
        }

        setupTabs();
        createChart();
        updateFootnote();
      });
    }
    function setupTabs() {
      const tabs = document.querySelectorAll('.tab');
      const indicator = document.querySelector('.tab-indicator');

      function updateTabIndicator(activeTab) {
        const container = activeTab.closest('.tabs-container');
        const containerRect = container.getBoundingClientRect();
        const tabRect = activeTab.getBoundingClientRect();

        indicator.style.left = (tabRect.left - containerRect.left) + 'px';
        indicator.style.width = tabRect.width + 'px';
        indicator.classList.add('active');
      }

      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const question = tab.getAttribute('data-question');
          active.question = question;
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          updateTabIndicator(tab);
          updateChart();
          updateFootnote();
        });
      });

      const activeTab = document.querySelector('.tab.active');
      if (activeTab) {
        updateTabIndicator(activeTab);
      }

      window.addEventListener('resize', () => {
        const currentActive = document.querySelector('.tab.active');
        if (currentActive) {
          updateTabIndicator(currentActive);
        }
      });
    }
    function updateFootnote() { const footnote = document.getElementById('footnote-container'); if (!footnote) { return; } if (active.question === 'ALL') { footnote.style.display = 'block'; } else { footnote.style.display = 'none'; } }
    function updateAnswerDisplay() { const answerEl = document.getElementById('correctAnswer'); const answerSection = document.getElementById('answerSection'); if (!answerEl || !answerSection) { return; } if (active.question === 'ALL') { answerSection.classList.add('hidden'); } else { answerEl.textContent = questionAnswers[active.question] || '-'; answerSection.classList.remove('hidden'); } }
    function getAggregated() {
      let rows;

      if (active.question === 'ALL') {
        // Hard-coded baseline values (GPT-5)
        const maxLma = 1436;
        const maxAa = 68;
        const maxLb = 73.48;

        rows = rawData.map(d => {
          const model = String(d.model || '').trim();
          const name = String(d.name || '').trim();
          let lma = parseNum(d.lma);
          let aa = parseNum(d.aa);
          let lb = parseNum(d.lb);

          // Count how many scores are missing (zero)
          const hasLma = lma > 0;
          const hasAa = aa > 0;
          const hasLb = lb > 0;
          const missingCount = (hasLma ? 0 : 1) + (hasAa ? 0 : 1) + (hasLb ? 0 : 1);

          // Normalize scores: divide by (2 * max) so best model gets 0.5
          let normalizedLma = lma > 0 ? (lma / (2 * maxLma)) : 0;
          let normalizedAa = aa > 0 ? (aa / (2 * maxAa)) : 0;
          let normalizedLb = lb > 0 ? (lb / (2 * maxLb)) : 0;

          // If exactly one score is missing, compute it as the average of the other two
          if (missingCount === 1) {
            if (!hasLma && hasAa && hasLb) {
              normalizedLma = (normalizedAa + normalizedLb) / 2;
            } else if (!hasAa && hasLma && hasLb) {
              normalizedAa = (normalizedLma + normalizedLb) / 2;
            } else if (!hasLb && hasLma && hasAa) {
              normalizedLb = (normalizedLma + normalizedAa) / 2;
            }
          }

          // Ranking score is the average of the three normalized scores
          const rankingScore = (normalizedLma + normalizedAa + normalizedLb) / 3;
          return { model: model, name: name, score: rankingScore, lmaSegment: normalizedLma, aaSegment: normalizedAa, lbSegment: normalizedLb };
        });
      } else if (active.question === 'LMArena') {
        rows = rawData.map(d => ({
          model: String(d.model || '').trim(),
          name: String(d.name || '').trim(),
          score: parseNum(d.lma)
        }));
      } else if (active.question === 'Artificial Analysis') {
        rows = rawData.map(d => ({
          model: String(d.model || '').trim(),
          name: String(d.name || '').trim(),
          score: parseNum(d.aa)
        }));
      } else if (active.question === 'LiveBench') {
        rows = rawData.map(d => ({
          model: String(d.model || '').trim(),
          name: String(d.name || '').trim(),
          score: parseNum(d.lb)
        }));
      } else {
        rows = rawData.map(d => ({
          model: String(d.model || '').trim(),
          name: String(d.name || '').trim(),
          score: parseNum(d.lma)
        }));
      }

      return rows.filter(d => d.score > 0).map(d => ({
        id: d.name || d.model,
        model: d.model,
        name: d.name,
        wins: d.score,
        ties: 0,
        total: d.score,
        logo: modelIcons[d.model] || '',
        color: modelColors[d.model] || '#1a73e8',
        lmaSegment: d.lmaSegment || 0,
        aaSegment: d.aaSegment || 0,
        lbSegment: d.lbSegment || 0
      }));
    }
    function getTop20() { return getAggregated().slice().sort((a, b) => b.total - a.total).slice(0, displayLimit); }
    function getXDomain() {
      if (active.question === 'LMArena') { return [1300, 1500]; }
      if (active.question === 'Artificial Analysis') { return [15, 60]; }
      if (active.question === 'LiveBench') { return [40, 90]; }
      if (active.question === 'ALL') {
        const data = getAggregated();
        const minScore = d3.min(data, d => d.total) || 0;
        const maxScore = d3.max(data, d => d.total) || 0;
        const lower = Math.max(0, minScore - 0.02);
        const upper = Math.min(1, maxScore + 0.02);
        return [lower, upper];
      }
      const maxScore = d3.max(getAggregated(), d => d.total) || 1500;
      const upper = Math.max(1500, maxScore);
      return [0, upper];
    }
    function clampToDomain(value, domain) {
      if (!domain || domain.length < 2) { return value || 0; }
      const num = Number(value);
      const safe = isNaN(num) ? domain[0] : num;
      return Math.max(domain[0], Math.min(domain[1], safe));
    }
    function getValueFormatter() {
      if (active.question === 'ALL') { return d3.format('.3f'); }
      if (active.question === 'LiveBench') { return d3.format('.1f'); }
      return d3.format('.0f');
    }
    let chartState = { svg: null, g: null, x: null, y: null, yAxisGroup: null, xAxisGroup: null, bgLayer: null, rowBG: null, width: 0, height: 0, margin: null, barsWin: null, barsTie: null, barsTieOverlay: null, logos: null, sizeFactor: 1, axisFS: 12, valueFS: 12, sourceFS: 12, logoWH: 24, logoWidth: 24, logoSize: 24, padding: 16, xDomain: [0, 1], xMin: 0, xMax: 1 };
    function barPath(x0, x1, yCenter, h, opts) {
      const o = opts || {};
      const roundStart = o.roundStart !== false;
      const roundEnd = o.roundEnd !== false;
      const baseRadius = o.baseRadius || 4;
      const yTop = yCenter - h / 2;
      const yBot = yCenter + h / 2;
      const width = Math.max(0, x1 - x0);
      if (width <= 0) { return `M ${x0} ${yTop} L ${x0} ${yBot} L ${x0} ${yBot} Z`; }

      const radius = Math.min(baseRadius, h / 2, width / 2);
      const rStart = roundStart ? radius : 0;

      const useSlash = (styleMode === 1 && roundEnd);
      const rEnd = (!useSlash && roundEnd) ? radius : 0;

      let path = `M ${x0} ${yTop + rStart}`;

      if (rStart) { path += ` A ${rStart} ${rStart} 0 0 1 ${x0 + rStart} ${yTop}`; }
      else { path += ` L ${x0} ${yTop}`; }

      if (useSlash) {
        const slashW = h * 0.5;
        path += ` L ${x1} ${yTop}`;
        path += ` L ${x1 - slashW} ${yBot}`;
      } else {
        path += ` L ${x1 - rEnd} ${yTop}`;
        if (rEnd) { path += ` A ${rEnd} ${rEnd} 0 0 1 ${x1} ${yTop + rEnd}`; }
        else { path += ` L ${x1} ${yTop}`; }

        path += ` L ${x1} ${yBot - rEnd}`;
        if (rEnd) { path += ` A ${rEnd} ${rEnd} 0 0 1 ${x1 - rEnd} ${yBot}`; }
        else { path += ` L ${x1} ${yBot}`; }
      }

      path += ` L ${x0 + rStart} ${yBot}`;
      if (rStart) { path += ` A ${rStart} ${rStart} 0 0 1 ${x0} ${yBot - rStart}`; }
      else { path += ` L ${x0} ${yBot}`; }

      path += ' Z';
      return path;
    }
    function truncateAxisLabels(maxWidth) {
      if (!chartState.yAxisGroup) { return; } chartState.yAxisGroup.selectAll('text').each(function (d) {
        const text = d3.select(this);
        const full = d;
        let shown = full;
        text.text(shown);
        if (this.getComputedTextLength() <= maxWidth) { text.attr('data-full', full); return; }
        let low = 0;
        let high = full.length;
        while (low < high) {
          const mid = Math.floor((low + high) / 2);
          text.text(full.slice(0, mid) + '…');
          if (this.getComputedTextLength() <= maxWidth) { low = mid + 1; }
          else { high = mid; }
        }
        const cut = Math.max(1, low - 1); text.text(full.slice(0, cut) + '…'); let title = text.select('title'); if (title.empty()) { text.append('title').text(full); } else { title.text(full); }
      });
    }
    function getBarHeight(scaleBand, sizeFactor) { const bw = scaleBand.bandwidth(); const k = .95 + .03 * (sizeFactor || 1); return Math.max(10, bw * k); }
    function createColorPattern(defs, color) { const lightColor = lighten(color, .35); const patternId = 'crossPattern-' + color.replace('#', ''); if (defs.select('#' + patternId).empty()) { const pattern = defs.append('pattern').attr('id', patternId).attr('patternUnits', 'userSpaceOnUse').attr('width', 8).attr('height', 8); pattern.append('rect').attr('width', 8).attr('height', 8).attr('fill', lightColor); pattern.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 8).attr('y2', 8).attr('stroke', color).attr('stroke-width', 1.5).attr('opacity', 0.6); pattern.append('line').attr('x1', 8).attr('y1', 0).attr('x2', 0).attr('y2', 8).attr('stroke', color).attr('stroke-width', 1.5).attr('opacity', 0.6); } return 'url(#' + patternId + ')'; }
    function computeFooterMargin(containerWidth, containerHeight, sizeFactor) { const compact = window.matchMedia('(max-height:500px), (max-width:640px)').matches; const minW = 320; const minH = 240; const thrW = 640; const thrH = 500; if (compact) { const tW = Math.max(0, Math.min(1, (containerWidth - minW) / (thrW - minW))); const tH = Math.max(0, Math.min(1, (containerHeight - minH) / (thrH - minH))); const t = Math.min(tW, tH); return Math.round(5 + (24 - 5) * t); } return Math.round(70 * sizeFactor); }
    function createChart() {
      const data = getTop20();
      d3.select('#chart').selectAll('*').remove();
      const c1 = document.getElementById('container1');
      const rect = c1 ? c1.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight };
      const containerWidth = Math.max(320, rect.width);
      const isCompactWidth = containerWidth < 500;
      const containerHeight = Math.max(240, rect.height);
      const sizeFactor = Math.max(.6, Math.min(1.15, Math.min(containerWidth / 900, containerHeight / 650)));

      const BaseAxisFontSize = isCompactWidth ? 11 : 16;
      const MinAxisFontSize = isCompactWidth ? 9 : 12;

      let axisFS = Math.max(MinAxisFontSize, Math.round(BaseAxisFontSize * sizeFactor));
      const valueFS = Math.max(9, Math.round(12 * sizeFactor));
      const sourceFS = Math.max(9, Math.round(12 * sizeFactor));
      const logoWH = Math.max(10, Math.round(24 * sizeFactor));
      chartState.sizeFactor = sizeFactor;
      chartState.axisFS = axisFS;
      chartState.valueFS = valueFS;
      chartState.sourceFS = sourceFS;
      chartState.logoWH = logoWH;
      const responsiveRadius = 4;
      chartState.barRadius = responsiveRadius;
      const tempSvg = d3.select('body').append('svg').style('visibility', 'hidden');
      const tempText = tempSvg.append('text').style('font-size', BaseAxisFontSize + 'px').style('font-family', 'sans-serif');
      const allTop20 = getAggregated().slice(0, 1000).map(d => d.id);
      const uniqLabels = Array.from(new Set(allTop20));
      let maxLabelWidth = 0;
      uniqLabels.forEach(id => {
        tempText.text(id);
        const w = tempText.node().getBoundingClientRect().width;
        maxLabelWidth = Math.max(maxLabelWidth, w);
      });
      tempSvg.remove();
      const logoWidth = 24;
      const padding = 16;
      const dynamicLeftMargin = Math.min(maxLabelWidth + logoWidth + padding, Math.max(150, containerWidth * .35));
      const availForText = Math.max(40, dynamicLeftMargin - logoWidth - padding - 8);

      const fitFS = Math.floor(BaseAxisFontSize * (availForText / Math.max(1, maxLabelWidth)));

      axisFS = Math.max(MinAxisFontSize, Math.min(axisFS, fitFS));
      chartState.axisFS = axisFS;
      const footerH = computeFooterMargin(containerWidth, containerHeight, sizeFactor);
      const margin = { top: 12, right: Math.max(30, containerWidth * .05), bottom: footerH, left: dynamicLeftMargin };
      const width = containerWidth - margin.left - margin.right;
      const maxRowsH = containerHeight - margin.top - margin.bottom;
      const height = Math.max(180, maxRowsH);
      const svg = d3.select('#chart').attr('width', containerWidth).attr('height', height + margin.top + margin.bottom).attr('viewBox', `0 0 ${containerWidth} ${height + margin.top + margin.bottom}`).style('width', '100%').style('height', '100%');
      chartState.svg = svg;
      chartState.width = width;
      chartState.height = height;
      const defs = svg.append('defs');
      const grad = defs.append('linearGradient').attr('id', 'gradBlue').attr('x1', '0%').attr('x2', '100%').attr('y1', '0%').attr('y2', '0%');
      grad.append('stop').attr('offset', '0%').attr('stop-color', '#cfe8ff');
      grad.append('stop').attr('offset', '100%').attr('stop-color', '#1f78ff');
      const grad2 = defs.append('linearGradient').attr('id', 'gradBlueTie').attr('x1', '0%').attr('x2', '100%').attr('y1', '0%').attr('y2', '0%');
      grad2.append('stop').attr('offset', '0%').attr('stop-color', '#e8f3ff');
      grad2.append('stop').attr('offset', '100%').attr('stop-color', '#7fb2ff');
      const patternTie = defs.append('pattern').attr('id', 'crossPattern').attr('patternUnits', 'userSpaceOnUse').attr('width', 8).attr('height', 8);
      patternTie.append('rect').attr('width', 8).attr('height', 8).attr('fill', '#c4c9d6');
      patternTie.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 8).attr('y2', 8).attr('stroke', 'rgba(79,109,181,.75)').attr('stroke-width', 1.5);
      patternTie.append('line').attr('x1', 8).attr('y1', 0).attr('x2', 0).attr('y2', 8).attr('stroke', 'rgba(79,109,181,.75)').attr('stroke-width', 1.5);

      const filter = defs.append('filter').attr('id', 'blurFilter').append('feGaussianBlur').attr('stdDeviation', 4);
      const mask = defs.append('mask').attr('id', 'highlightMask');
      mask.append('rect').attr('class', 'mask-bg').attr('fill', 'white');
      mask.append('rect').attr('class', 'mask-hole').attr('fill', 'black').style('filter', 'url(#blurFilter)');

      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
      chartState.g = g;
      const bgLayer = g.append('g').attr('class', 'bg-layer');
      chartState.bgLayer = bgLayer;
      const xDomain = getXDomain();
      const x = d3.scaleLinear().domain(xDomain).range([0, width]);
      chartState.x = x;
      chartState.xDomain = xDomain;
      chartState.xMin = xDomain[0];
      chartState.xMax = xDomain[1];
      const yDomain = data.map(d => d.id);
      const y = d3.scaleBand().domain(yDomain).range([0, height]).padding(Math.max(.2, Math.min(.45, .55 - .25 * sizeFactor)));
      chartState.y = y;
      chartState.margin = margin;
      chartState.logoWidth = logoWidth;
      chartState.padding = padding;
      const clampValue = v => clampToDomain(v, xDomain);
      const baseValue = xDomain[0];
      const baseX = x(baseValue);
      const step = y.step();
      const padGap = (step - y.bandwidth()) / 2;
      const rowIdx = d3.range(yDomain.length);
      chartState.rowBG = bgLayer.selectAll('rect.row-bg').data(rowIdx, d => d).enter().append('rect').attr('class', 'row-bg').attr('x', -margin.left).attr('y', i => y(yDomain[i]) - padGap).attr('width', width + margin.left + margin.right).attr('height', step).attr('fill', (d, i) => i % 2 ? "#f5f5f5" : "#ffffff").attr('pointer-events', 'none').lower();
      chartState.yAxisGroup = g.append('g').attr('class', 'axis axis-y').call(d3.axisLeft(y));
      chartState.yAxisGroup.selectAll('text').style('font-size', axisFS + 'px');
      truncateAxisLabels(margin.left - logoWidth - padding - 8);
      const xAxis = active.question === 'ALL' ? d3.axisBottom(x).ticks(5).tickFormat(d => d.toFixed(3)) : active.question === 'LiveBench' ? d3.axisBottom(x).tickFormat(d => d.toFixed(1)) : d3.axisBottom(x).tickFormat(d => Math.round(d));
      chartState.xAxisGroup = g.append('g').attr('class', 'axis axis-x').attr('transform', `translate(0,${height})`).call(xAxis);
      chartState.xAxisGroup.selectAll('text').style('font-size', axisFS + 'px');
      const barH = getBarHeight(y, sizeFactor);
      const logoSize = Math.min(barH, logoWH);
      chartState.logoSize = logoSize;
      const winsSel = g.selectAll('path.bar-win').data(data, d => d.id).enter().append('path').attr('class', 'bar-win').attr('d', d => barPath(baseX, x(clampValue(d.wins)), y(d.id) + y.bandwidth() / 2, barH, d.ties > 0 ? { roundStart: false, roundEnd: false, baseRadius: responsiveRadius } : { roundStart: false, baseRadius: responsiveRadius })).attr('fill', d => d.color || 'url(#gradBlue)');
      const tieSel = g.selectAll('path.bar-tie').data(data, d => d.id).enter().append('path').attr('class', 'bar-tie').attr('d', d => barPath(x(clampValue(d.wins)), x(clampValue(d.total)), y(d.id) + y.bandwidth() / 2, barH, d.wins > 0 ? { roundStart: false, baseRadius: responsiveRadius } : { baseRadius: responsiveRadius })).attr('fill', d => { if (d.ties > 0) { return d.color ? createColorPattern(defs, d.color) : ('url(#crossPattern)'); } return d.color ? lighten(d.color, .35) : 'url(#gradBlueTie)'; });
      chartState.barsWin = g.selectAll('path.bar-win');
      chartState.barsTie = g.selectAll('path.bar-tie');
      chartState.barsWin.each(function (d) {
        this._x0 = baseX;
        this._x1 = x(clampValue(d.wins));
        this._yc = y(d.id) + y.bandwidth() / 2;
        this._h = barH;
      });
      chartState.barsTie.each(function (d) {
        this._x0 = x(clampValue(d.wins));
        this._x1 = x(clampValue(d.total));
        this._yc = y(d.id) + y.bandwidth() / 2;
        this._h = barH;
      });
      const fmt = getValueFormatter();
      g.selectAll('text.value').data(data, d => d.id).enter().append('text').attr('class', 'value').attr('x', d => x(clampValue(d.total)) - 12).attr('y', d => y(d.id) + y.bandwidth() / 2 + Math.round(4 * sizeFactor)).attr('text-anchor', 'end').attr('font-size', chartState.valueFS + 'px').attr('font-weight', '600').attr('fill', '#ffffff').text(d => fmt(d.total));
      g.selectAll('image.logo').data(data, d => d.id).enter().append('image').attr('class', 'logo').attr('x', d => x(clampValue(d.total)) + 6).attr('y', d => y(d.id) + (y.bandwidth() - logoSize) / 2).attr('width', logoSize).attr('height', logoSize).attr('href', d => d.logo).attr('xlink:href', d => d.logo);
      chartState.logos = g.selectAll('image.logo');

      const overlay = svg.append('rect').attr('class', 'highlight-overlay')
        .attr('fill', '#f9fafc')
        .attr('pointer-events', 'none')
        .attr('opacity', 0);

      if (!isCompactWidth) {
        const aiwW = 133 * sizeFactor;
        const aiwH = 53 * sizeFactor;
        svg.append('a')
          .attr('href', 'https://aiworld.eu')
          .attr('target', '_blank')
          .append('image')
          .attr('href', 'https://aiworld.eu/logo-transparent.svg')
          .attr('width', aiwW)
          .attr('height', aiwH)
          .attr('x', margin.left + width - aiwW - (10 * sizeFactor))
          .attr('y', margin.top + height - aiwH - (10 * sizeFactor))
          .style('cursor', 'pointer');
      }

      updateHighlight(data, false);

      const hoverSel = g.selectAll('.bar-win,.bar-tie');
      hoverSel.on('mousemove', (event, d) => {
        if (highlightMode && !highlightPaused && d.id !== highlightMode) return;
        let html = '';
        if (active.question === 'ALL') {
          const rawEntry = rawData.find(r => String(r.model || '').trim() === d.model);
          const lmaScore = rawEntry ? parseNum(rawEntry.lma) : 0;
          const aaScore = rawEntry ? parseNum(rawEntry.aa) : 0;
          const lbScore = rawEntry ? parseNum(rawEntry.lb) : 0;

          html = `<div style="text-align:center;margin-bottom:4px;"><b>${d.name || d.id}</b>${d.model ? '<br><span style="font-size:0.9em;">' + d.model + '</span>' : ''}</div>`;
          html += `<table style="width:100%;margin-top:4px;border-spacing:0;">`;
          html += `<tr><td style="text-align:left;padding:2px 8px 2px 0;">LMArena</td><td style="text-align:right;padding:2px 0;">${lmaScore > 0 ? Math.round(lmaScore) : '-'}</td></tr>`;
          html += `<tr><td style="text-align:left;padding:2px 8px 2px 0;">Artificial Analysis</td><td style="text-align:right;padding:2px 0;">${aaScore > 0 ? aaScore.toFixed(1) : '-'}</td></tr>`;
          html += `<tr><td style="text-align:left;padding:2px 8px 2px 0;">LiveBench</td><td style="text-align:right;padding:2px 0;">${lbScore > 0 ? lbScore.toFixed(1) : '-'}</td></tr>`;
          html += `</table>`;
        } else {
          html = `<b>${d.name || d.id}</b><br>${d.model ? d.model + '<br>' : ''}Score: ${fmt(d.total)}`;
        }
        tooltip.html(html).style('left', (event.pageX + 12) + 'px').style('top', (event.pageY - 28) + 'px').style('opacity', 1);
      }).on('mouseleave', () => { tooltip.style('opacity', 0); });
    }
    function updateHighlight(data, animate) {
      if (!chartState.svg) return;
      const overlay = chartState.svg.select('.highlight-overlay');
      const maskHole = chartState.svg.select('#highlightMask .mask-hole');
      const maskBg = chartState.svg.select('#highlightMask .mask-bg');

      if (highlightMode && !highlightPaused) {
        const found = data.find(d => d.id === highlightMode);
        if (found) {
          const y = chartState.y;
          const step = y.step();
          const gap = (step - y.bandwidth()) / 2;
          const yPos = chartState.margin.top + y(found.id) - gap;

          maskBg.attr('width', chartState.width + chartState.margin.left + chartState.margin.right)
            .attr('height', chartState.height + chartState.margin.top + chartState.margin.bottom);

          const holeSel = animate ? maskHole.transition().duration(700) : maskHole;
          holeSel.attr('x', 0)
            .attr('y', yPos)
            .attr('width', chartState.width + chartState.margin.left + chartState.margin.right)
            .attr('height', step);

          const overlaySel = animate ? overlay.transition().duration(700) : overlay;
          overlaySel.attr('width', chartState.width + chartState.margin.left + chartState.margin.right)
            .attr('height', chartState.height + chartState.margin.top + chartState.margin.bottom)
            .attr('mask', 'url(#highlightMask)')
            .attr('opacity', 0.8);
        } else {
          const overlaySel = animate ? overlay.transition().duration(700) : overlay;
          overlaySel.attr('opacity', 0);
        }
      } else {
        const overlaySel = animate ? overlay.transition().duration(700) : overlay;
        overlaySel.attr('opacity', 0);
      }
    }
    function pauseHighlight() {
      if (!highlightMode) return;
      clearTimeout(highlightPauseTimeout);
      if (!highlightPaused) {
        highlightPaused = true;
        updateHighlight(getTop20(), true);
      }
      highlightPauseTimeout = setTimeout(() => {
        highlightPaused = false;
        updateHighlight(getTop20(), true);
      }, 1000);
    }
    function updateChart() {
      const data = getTop20();
      const x = chartState.x;
      const y = chartState.y;
      const g = chartState.g || chartState.svg.select('g');
      const responsiveRadius = chartState.barRadius || 8;
      const newDomain = data.map(d => d.id);
      const newXDomain = getXDomain();
      const prevXDomain = chartState.xDomain || x.domain();
      const domainChanged = !prevXDomain || prevXDomain[0] !== newXDomain[0] || prevXDomain[1] !== newXDomain[1];
      if (domainChanged) {
        x.domain(newXDomain);
        chartState.xDomain = newXDomain;
        chartState.xMin = newXDomain[0];
        chartState.xMax = newXDomain[1];
      }
      const clampValue = v => clampToDomain(v, chartState.xDomain);
      const baseValue = chartState.xDomain[0];
      const baseX = x(baseValue);
      if (chartState.xAxisGroup) {
        const xAxis = active.question === 'ALL' ? d3.axisBottom(x).ticks(5).tickFormat(d => d.toFixed(3)) : active.question === 'LiveBench' ? d3.axisBottom(x).tickFormat(d => d.toFixed(1)) : d3.axisBottom(x).tickFormat(d => Math.round(d));
        chartState.xAxisGroup.transition().duration(700).call(xAxis);
        chartState.xAxisGroup.selectAll('text').style('font-size', chartState.axisFS + 'px');
      }
      y.domain(newDomain);
      y.padding(Math.max(.2, Math.min(.45, .55 - .25 * (chartState.sizeFactor || 1))));
      chartState.yAxisGroup.transition().duration(700).call(d3.axisLeft(y)).on('end', function () { truncateAxisLabels(chartState.margin.left - (chartState.logoWidth || 24) - (chartState.padding || 16) - 8); }).selection().selectAll('text').style('font-size', chartState.axisFS + 'px');
      const idx = d3.range(newDomain.length);
      const bg = chartState.bgLayer.selectAll('rect.row-bg').data(idx, d => d);
      bg.join(
        enter => enter.append('rect').attr('class', 'row-bg').attr('x', -chartState.margin.left).attr('y', i => y(newDomain[i]) - ((y.step() - y.bandwidth()) / 2)).attr('width', chartState.width + chartState.margin.left + chartState.margin.right).attr('height', y.step()).attr('fill', (d, i) => i % 2 ? "#f5f5f5" : "#ffffff").attr('opacity', 0).transition().duration(700).attr('opacity', 1),
        update => update.attr('fill', (d, i) => i % 2 ? "#f5f5f5" : "#ffffff").transition().duration(700).attr('y', i => y(newDomain[i]) - ((y.step() - y.bandwidth()) / 2)).attr('height', y.step()),
        exit => exit.transition().duration(500).attr('opacity', 0).remove()
      );
      chartState.bgLayer.lower();
      const barHNow = getBarHeight(y, chartState.sizeFactor || 1);
      const logoSize = Math.min(barHNow, chartState.logoWH || 24);
      chartState.logoSize = logoSize;
      const wins = chartState.svg.select('g').selectAll('path.bar-win').data(data, d => d.id);
      wins.join(
        enter => enter.append('path').attr('class', 'bar-win').each(function (d) {
          this._x0 = baseX;
          this._x1 = baseX;
          this._yc = y(d.id) + y.bandwidth() / 2;
          this._h = barHNow;
        }).attr('d', d => barPath(baseX, baseX, y(d.id) + y.bandwidth() / 2, barHNow, d.ties > 0 ? { roundStart: false, roundEnd: false, baseRadius: responsiveRadius } : { roundStart: false, baseRadius: responsiveRadius })).attr('fill', d => d.color || 'url(#gradBlue)'),
        update => update.attr('fill', d => d.color || 'url(#gradBlue)'),
        exit => exit.transition().duration(350).attrTween('d', function (d) {
          const xStart = this._x1 ?? baseX;
          const yStart = this._yc ?? (y(d.id) + y.bandwidth() / 2);
          const hStart = this._h ?? barHNow;
          const xEnd = baseX;
          const yEnd = y(d.id) + y.bandwidth() / 2;
          const hEnd = barHNow;
          return function (t) {
            const xi = xStart + (xEnd - xStart) * t;
            const yi = yStart + (yEnd - yStart) * t;
            const hi = hStart + (hEnd - hStart) * t;
            return barPath(baseX, xi, yi, hi, d.ties > 0 ? { roundStart: false, roundEnd: false, baseRadius: responsiveRadius } : { roundStart: false, baseRadius: responsiveRadius });
          };
        }).on('end', function () { this.remove(); })
      ).transition().duration(700).attrTween('d', function (d) {
        const xStart = this._x1 ?? baseX;
        const yStart = this._yc ?? (y(d.id) + y.bandwidth() / 2);
        const hStart = this._h ?? barHNow;
        const xEnd = x(clampValue(d.wins));
        const yEnd = y(d.id) + y.bandwidth() / 2;
        const hEnd = getBarHeight(y, chartState.sizeFactor || 1);
        return function (t) {
          const xi = xStart + (xEnd - xStart) * t;
          const yi = yStart + (yEnd - yStart) * t;
          const hi = hStart + (hEnd - hStart) * t;
          return barPath(baseX, xi, yi, hi, d.ties > 0 ? { roundStart: false, roundEnd: false, baseRadius: responsiveRadius } : { roundStart: false, baseRadius: responsiveRadius });
        };
      }).on('end', function (d) {
        this._x0 = baseX;
        this._x1 = x(clampValue(d.wins));
        this._yc = y(d.id) + y.bandwidth() / 2;
        this._h = getBarHeight(y, chartState.sizeFactor || 1);
      });
      chartState.barsWin = chartState.svg.select('g').selectAll('path.bar-win');
      const ties = chartState.svg.select('g').selectAll('path.bar-tie').data(data, d => d.id);
      const defs = chartState.svg.select('defs');
      ties.join(
        enter => enter.append('path').attr('class', 'bar-tie').each(function (d) {
          this._x0 = baseX;
          this._x1 = baseX;
          this._yc = y(d.id) + y.bandwidth() / 2;
          this._h = barHNow;
        }).attr('d', d => barPath(baseX, baseX, y(d.id) + y.bandwidth() / 2, barHNow, d.wins > 0 ? { roundStart: false, baseRadius: responsiveRadius } : { baseRadius: responsiveRadius })).attr('fill', d => { if (d.ties > 0) { return d.color ? createColorPattern(defs, d.color) : ('url(#crossPattern)'); } return d.color ? lighten(d.color, .35) : 'url(#gradBlueTie)'; }),
        update => update.attr('fill', d => { if (d.ties > 0) { return d.color ? createColorPattern(defs, d.color) : ('url(#crossPattern)'); } return d.color ? lighten(d.color, .35) : 'url(#gradBlueTie)'; }),
        exit => exit.transition().duration(350).attrTween('d', function (d) {
          const xStart = this._x1 ?? baseX;
          const yStart = this._yc ?? (y(d.id) + y.bandwidth() / 2);
          const hStart = this._h ?? barHNow;
          const xEnd = baseX;
          const yEnd = y(d.id) + y.bandwidth() / 2;
          const hEnd = barHNow;
          return function (t) {
            const xi = xStart + (xEnd - xStart) * t;
            const yi = yStart + (yEnd - yStart) * t;
            const hi = hStart + (hEnd - hStart) * t;
            return barPath(baseX, xi, yi, hi, d.wins > 0 ? { roundStart: false, baseRadius: responsiveRadius } : { baseRadius: responsiveRadius });
          };
        }).on('end', function () { this.remove(); })
      ).transition().duration(700).attrTween('d', function (d) {
        const xStart = this._x1 ?? baseX;
        const yStart = this._yc ?? (y(d.id) + y.bandwidth() / 2);
        const hStart = this._h ?? barHNow;
        const xEnd = x(clampValue(d.total));
        const yEnd = y(d.id) + y.bandwidth() / 2;
        const hEnd = getBarHeight(y, chartState.sizeFactor || 1);
        return function (t) {
          const xi = xStart + (xEnd - xStart) * t;
          const yi = yStart + (yEnd - yStart) * t;
          const hi = hStart + (hEnd - hStart) * t;
          const mid = x(clampValue(d.wins));
          const xi0 = xi < mid ? mid : xi;
          return barPath(mid, xi0, yi, hi, d.wins > 0 ? { roundStart: false, baseRadius: responsiveRadius } : { baseRadius: responsiveRadius });
        };
      }).on('end', function (d) {
        this._x0 = x(clampValue(d.wins));
        this._x1 = x(clampValue(d.total));
        this._yc = y(d.id) + y.bandwidth() / 2;
        this._h = getBarHeight(y, chartState.sizeFactor || 1);
      });
      chartState.barsTie = chartState.svg.select('g').selectAll('path.bar-tie');
      const fmt = getValueFormatter();
      const values = chartState.svg.select('g').selectAll('text.value').data(data, d => d.id);
      values.join(
        enter => enter.append('text').attr('class', 'value').attr('x', d => x(clampValue(d.total)) - 12).attr('y', d => y(d.id) + y.bandwidth() / 2 + Math.round(4 * (chartState.sizeFactor || 1))).attr('text-anchor', 'end').attr('font-size', (chartState.valueFS || 12) + 'px').attr('font-weight', '600').attr('fill', '#ffffff').attr('opacity', 0).text(d => fmt(d.total)).transition().duration(700).attr('opacity', 1),
        update => update.transition().duration(700).attr('x', d => x(clampValue(d.total)) - 12).attr('y', d => y(d.id) + y.bandwidth() / 2 + Math.round(4 * (chartState.sizeFactor || 1))).tween('text', function (d) {
          const that = d3.select(this);
          const parseNum = v => +String(v).replace(/[^0-9eE+.-]/g, '');
          const start = parseNum(that.text());
          const i = d3.interpolateNumber(isNaN(start) ? d.total : start, d.total);
          return function (t) {
            that.text(fmt(i(t)));
          };
        }),
        exit => exit.transition().duration(500).attr('opacity', 0).remove()
      );
      const logos = chartState.svg.select('g').selectAll('image.logo').data(data, d => d.id);
      logos.join(
        enter => enter.append('image').attr('class', 'logo').attr('x', d => x(clampValue(d.total)) + 6).attr('y', d => y(d.id) + (y.bandwidth() - logoSize) / 2).attr('width', logoSize).attr('height', logoSize).attr('href', d => d.logo).attr('xlink:href', d => d.logo).attr('opacity', 0).transition().duration(700).attr('opacity', 1),
        update => update.transition().duration(700).attr('x', d => x(clampValue(d.total)) + 6).attr('y', d => y(d.id) + (y.bandwidth() - logoSize) / 2).attr('href', d => d.logo).attr('xlink:href', d => d.logo).attr('width', logoSize).attr('height', logoSize),
        exit => exit.transition().duration(500).attr('opacity', 0).remove()
      );
      chartState.logos = chartState.svg.select('g').selectAll('image.logo');
      const hoverSel = chartState.svg.select('g').selectAll('.bar-win,.bar-tie');
      hoverSel.on('mousemove', (event, d) => {
        if (highlightMode && !highlightPaused && d.id !== highlightMode) return;
        let html = '';
        if (active.question === 'ALL') {
          const rawEntry = rawData.find(r => String(r.model || '').trim() === d.model);
          const lmaScore = rawEntry ? parseNum(rawEntry.lma) : 0;
          const aaScore = rawEntry ? parseNum(rawEntry.aa) : 0;
          const lbScore = rawEntry ? parseNum(rawEntry.lb) : 0;

          html = `<div style="text-align:center;margin-bottom:4px;"><b>${d.name || d.id}</b>${d.model ? '<br><span style="font-size:0.9em;">' + d.model + '</span>' : ''}</div>`;
          html += `<table style="width:100%;margin-top:4px;border-spacing:0;">`;
          html += `<tr><td style="text-align:left;padding:2px 8px 2px 0;">LMArena</td><td style="text-align:right;padding:2px 0;">${lmaScore > 0 ? Math.round(lmaScore) : '-'}</td></tr>`;
          html += `<tr><td style="text-align:left;padding:2px 8px 2px 0;">Artificial Analysis</td><td style="text-align:right;padding:2px 0;">${aaScore > 0 ? aaScore.toFixed(1) : '-'}</td></tr>`;
          html += `<tr><td style="text-align:left;padding:2px 8px 2px 0;">LiveBench</td><td style="text-align:right;padding:2px 0;">${lbScore > 0 ? lbScore.toFixed(1) : '-'}</td></tr>`;
          html += `</table>`;
        } else {
          html = `<b>${d.name || d.id}</b><br>${d.model ? d.model + '<br>' : ''}Score: ${fmt(d.total)}`;
        }
        tooltip.html(html).style('left', (event.pageX + 12) + 'px').style('top', (event.pageY - 28) + 'px').style('opacity', 1);
      }).on('mouseleave', () => { tooltip.style('opacity', 0); });
      updateHighlight(data, true);
    }
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => { createChart(); }, 250);
    });
    load();
  </script>
</body>

</html>