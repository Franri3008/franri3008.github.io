<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style type="text/css">
body { margin: 0; overflow: hidden; height: 100vh; font-family: Arial, sans-serif; }

.viz-grid { display: grid; grid-template-rows: 17fr 2fr 1fr; grid-template-columns: 1fr 1fr; height: 100vh; width: 100vw; box-sizing: border-box; padding-bottom: clamp(8px, 2vh, 18px); }
#container1 { grid-row: 1; grid-column: 1 / span 2; overflow: hidden; min-height: 0; }
#container2 { grid-row: 2; grid-column: 1 / span 2; display: flex; align-items: center; justify-content: center; overflow: hidden; }

#treemap { width: 100%; height: 100%; min-height: 0; min-width: 0; }
.custom-legend { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: clamp(6px, 1.5vw, 14px); background: rgba(255, 255, 255, 0.9); padding: clamp(6px, 1.2vh, 10px) clamp(10px, 2vw, 16px); border-radius: clamp(6px, 1.2vw, 12px); box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: auto; max-width: 100%; max-height: 100%; font-size: clamp(10px, 1.6vw, 16px); font-weight: 600; }
.legend-item { display: flex; align-items: center; gap: 6px; cursor: pointer; transition: opacity 0.2s ease; font-weight: 600; color: #333; position: relative; }
.legend-item.inactive { opacity: 0.35; }
.legend-square { width: clamp(10px, 1.2vw, 14px); height: clamp(10px, 1.2vw, 14px); border-radius: 4px; box-shadow: 0 0 0 1px rgba(0,0,0,0.15) inset; }
.legend-item:focus-visible { outline: 2px solid rgba(0,0,0,0.5); outline-offset: 2px; }

@media (max-height: 500px) {
  .viz-grid { grid-template-rows: 1fr; grid-template-columns: 1fr; }
  #container1 { grid-row: 1; grid-column: 1; }
  #container2 { display: none !important; }
  .custom-legend { display: none !important; }
}

/* Special styling for AI factory sites */
@keyframes aiFactoryGlow {
  0%, 100% { filter: drop-shadow(0 0 3px rgba(255, 215, 0, 0.6)); }
  50% { filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.9)); }
}

.d3plus-Shape.ai-factory-site {
  animation: aiFactoryGlow 2s ease-in-out infinite;
}
</style>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3plus-hierarchy@1"></script>
</head>
<body>
<div class="viz-grid">
  <div id="container1" class="container treemap-container">
    <div id="treemap"></div>
  </div>
  <div id="container2" class="container legend-container">
    <div class="custom-legend" id="legend"></div>
  </div>
</div>
<script>
// D3 Tableau10 color scheme (matching fig3.html)
var tableau10 = ["#4e79a7","#f28e2c","#e15759","#76b7b2","#59a14f","#edc949","#af7aa1","#ff9da7","#9c755f","#bab0ab"];
var schemePaired = ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928"];
var countryColorPalette = tableau10.concat(schemePaired);

// Function to darken a color by a percentage
function darkenColor(color, percent) {
  var num = parseInt(color.replace("#",""), 16);
  var amt = Math.round(2.55 * percent);
  var R = (num >> 16) - amt;
  var G = (num >> 8 & 0x00FF) - amt;
  var B = (num & 0x0000FF) - amt;
  return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
    .toString(16).slice(1);
}

d3.csv("fig9.csv").then(function(csvData) {
  // Hardcoded color mapping to match the exact colors from the reference image
  var countryColorScale = {
    "Finland": "#4e79a7",        // Blue
    "France": "#f28e2c",         // Orange
    "Germany": "#e15759",        // Red
    "Ireland": "#76b7b2",        // Teal
    "Italy": "#59a14f",          // Green
    "Netherlands": "#edc949",    // Yellow
    "Spain": "#af7aa1",          // Purple
    "Sweden": "#ff9da7",         // Pink
    "Switzerland": "#9c755f",    // Brown
    "United Kingdom": "#bab0ab", // Gray
    // Additional countries in fig9 that might not be in fig3
    "Austria": "#a6cee3",        // Light blue
    "Poland": "#b2df8a",         // Light green
    "Bulgaria": "#fb9a99",       // Light red
    "Greece": "#fdbf6f",         // Light orange
    "Luxembourg": "#cab2d6",     // Light purple
    "Slovenia": "#ffff99"        // Light yellow
  };

  var originalData = csvData.map(function(d) {
    // Check for literal string "TRUE" (case-sensitive)
    var isAiFactory = d["AI factory site"] === "TRUE";
    var baseColor = countryColorScale[d.Country] || "#999999";
    var finalColor = isAiFactory ? darkenColor(baseColor, 30) : baseColor;

    return {
      name: d.Region,
      parent: d.Country,
      value: +d.value,
      aiFactory: isAiFactory,
      color: finalColor,
      baseColor: baseColor
    };
  });

  function normalizeData(arr){
    return arr.map(function(d){
      var parent = d.parent || d.group || d.domain || d.category || d.type || d.class;
      var name = d.name || d.id || d.label || d.title;
      var value = (d.value != null) ? +d.value : (d.count != null) ? +d.count : (d.size != null) ? +d.size : 0;
      return { parent: parent, name: name, value: value, aiFactory: d.aiFactory, color: d.color, baseColor: d.baseColor };
    });
  }

  var data = normalizeData(originalData);
  var groups = Array.from(new Set(data.map(function(d){ return d.parent; })));

  // Use base colors for legend (not darkened)
  var groupColors = {};
  groups.forEach(function(g){
    var item = originalData.find(function(x){ return x.parent === g; });
    groupColors[g] = item && item.baseColor ? item.baseColor : countryColorScale[g] || "#999999";
  });

  var activeGroups = new Set(groups);

  function getGroupColor(parent){ return groupColors[parent] || "#666666"; }

  // Map to get individual item colors
  var itemColorMap = {};
  originalData.forEach(function(d) {
    itemColorMap[d.name] = d.color;
  });

  function buildLegend(){
    var legend = document.getElementById('legend');
    if(!legend) return;
    legend.innerHTML = '';
    groups.forEach(function(g){
      var item = document.createElement('div');
      item.className = 'legend-item active';
      item.setAttribute('data-group', g);
      item.setAttribute('role','button');
      item.setAttribute('tabindex','0');
      item.setAttribute('aria-pressed','true');
      var square = document.createElement('div');
      square.className = 'legend-square';
      square.style.backgroundColor = getGroupColor(g);
      var label = document.createElement('span');
      label.textContent = g;
      item.appendChild(square);
      item.appendChild(label);
      item.addEventListener('click', function(){
        var grp = this.getAttribute('data-group');
        if(activeGroups.has(grp)){ activeGroups.delete(grp); } else { activeGroups.add(grp); }
        updateVisualization();
      });
      item.addEventListener('keydown', function(e){
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          var grp = this.getAttribute('data-group');
          if(activeGroups.has(grp)){ activeGroups.delete(grp); } else { activeGroups.add(grp); }
          updateVisualization();
        }
      });
      legend.appendChild(item);
    });
  }

  var treemap = new d3plus.Treemap()
    .select("#treemap")
    .data(data)
    .groupBy(["parent","name"])
    .tooltipConfig({
      title:function(d){ return d.name; },
      body:function(d){
        var aiFactoryText = d.aiFactory ? "<br><strong>AI Factory Site:</strong> Yes" : "";
        var base = "<strong>Country:</strong> " + (d.parent || d.id) + "<br><strong>Value:</strong> " + (d.value || 0) + aiFactoryText;
        return base;
      }
    })
    .sum("value")
    .layoutPadding(2)
    .legend(false)
    .color(function(d){
      // Use individual item color if available (for regions with AI factory darker shade)
      if(d.depth === 1 && itemColorMap[d.name]) {
        return itemColorMap[d.name];
      }
      // For country groups, use base color
      return getGroupColor(d.parent || d.id);
    })
    .shapeConfig({
      rx: 6,
      ry: 6,
      stroke:function(d){
        if(d.depth===0){
          return getGroupColor(d.id);
        }
        // AI factory sites get a special glowing border
        if(d.depth === 1 && d.aiFactory) {
          return "#FFD700"; // Gold border
        }
        return "transparent";
      },
      strokeWidth:function(d){
        if(d.depth===0){
          return 3;
        }
        // AI factory sites get thicker border
        if(d.depth === 1 && d.aiFactory) {
          return 3;
        }
        return 0;
      },
      strokeDasharray:function(d) {
        // AI factory sites get animated dashed border
        if(d.depth === 1 && d.aiFactory) {
          return "5,3";
        }
        return "0";
      }
    });

  function updateVisualization(){
    var normalized = normalizeData(originalData);
    var filteredData = normalized.filter(function(d){ return activeGroups.has(d.parent); });
    data = filteredData;

    // Update itemColorMap with filtered data
    itemColorMap = {};
    filteredData.forEach(function(d) {
      itemColorMap[d.name] = d.color;
    });

    treemap.data(data).render();
    document.querySelectorAll('.legend-item').forEach(function(item){
      var grp = item.getAttribute('data-group');
      var isActive = activeGroups.has(grp);
      item.classList.toggle('inactive', !isActive);
      item.classList.toggle('active', isActive);
      item.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }

  treemap.render();
  buildLegend();
  updateVisualization();

  // Apply special styling to AI factory sites after render
  function applyAIFactoryStyles() {
    setTimeout(function() {
      var svg = document.querySelector('#treemap svg');
      if (!svg) return;

      // Find all rectangle/shape elements
      var shapes = svg.querySelectorAll('rect, path');
      shapes.forEach(function(shape) {
        var parent = shape.parentElement;
        if (parent && parent.__data__) {
          var d = parent.__data__;
          if (d.aiFactory && d.depth === 1) {
            parent.classList.add('ai-factory-site');
          }
        }
      });
    }, 100);
  }

  // Call after renders
  applyAIFactoryStyles();

  // Re-apply after visualization updates
  var originalUpdateViz = updateVisualization;
  updateVisualization = function() {
    originalUpdateViz();
    applyAIFactoryStyles();
  };

  function renderToContainerSize(){
    var el = document.getElementById('treemap');
    if(!el) return;
    var rect = el.getBoundingClientRect();
    try {
      if(typeof treemap.width === 'function') treemap.width(rect.width);
      if(typeof treemap.height === 'function') treemap.height(rect.height);
    } catch(e) {}
    treemap.render();
  }

  var _resizeTimer;
  window.addEventListener('resize', function(){
    clearTimeout(_resizeTimer);
    _resizeTimer = setTimeout(renderToContainerSize, 120);
  });

  if (typeof ResizeObserver !== 'undefined') {
    var _ro = new ResizeObserver(function(){ renderToContainerSize(); });
    _ro.observe(document.getElementById('treemap'));
  }
});
</script>
</body>
</html>
