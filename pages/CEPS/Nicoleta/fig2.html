<!doctype html>
<html>
<head>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://www.paballand.com/js/d3plus-plot.v0.9.full.min.js"></script>
<style>
:root{--bg:#ffffff;--axis:#cfcfcf;--grid:#e9e9e9;--text:#6b6b6b;--text-strong:#333333;--muted:#9aa0a6;}
html,body{height:100%;}
body{margin:0;overflow:hidden;background:var(--bg);font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;color:var(--text);}
.container{position:relative;display:flex;flex-direction:column;height:100vh;background:var(--bg);}
#chart{flex:1 1 auto;}
.legend{position:absolute;top:14px;right:14px;display:flex;flex-direction:column;gap:8px;padding:10px 12px;background:rgba(255,255,255,.95);border:1px solid #e5e5e5;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.06);}
.legend-item{display:flex;align-items:center;gap:10px;font-size:12px;color:var(--text);}
.box{width:12px;height:12px;border-radius:50%;border:1px solid #ffffff;box-shadow:0 0 0 1px rgba(0,0,0,.05) inset;}
.tooltip-table{width:100%;border-collapse:collapse;}
.tooltip-table .title{color:var(--muted);}
.tooltip-table .data{text-align:right;color:var(--text-strong);}
.tooltip-footer{opacity:.6;}
#chart svg{background:var(--bg);}
.d3plus-Axis path.domain{stroke:var(--axis)!important;}
.d3plus-Axis .tick line{stroke:var(--grid)!important;}
.d3plus-Axis .tick text{fill:var(--text)!important;font-size:12px!important;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif!important;}
.d3plus-Axis .title{fill:var(--text-strong)!important;font-size:14px!important;font-weight:600!important;}
.d3plus-tooltip{background:#ffffff!important;border:1px solid #e5e5e5!important;border-radius:8px!important;box-shadow:0 10px 24px rgba(0,0,0,.1)!important;color:var(--text-strong)!important;}
.d3plus-tooltip-title{font-weight:700!important;font-size:13px!important;color:var(--text-strong)!important;}
.d3plus-tooltip-body{font-size:12px!important;color:var(--text)!important;}
.custom-label{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:10px;fill:#000;opacity:1;font-weight:400;transition:opacity .2s ease,font-size .2s ease,font-weight .2s ease;pointer-events:none;transform-origin:center;}
.custom-label.collision{opacity:.35;}
.custom-label.hover{opacity:1!important;font-size:16px!important;font-weight:700!important;}
.custom-label, text.custom-label{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif!important;font-size:10px!important;fill:#000!important;stroke:none!important;font-weight:400!important;}
tspan{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:12px;font-style:normal;}
.footer-note{position:fixed;right:12px;bottom:10px;font-size:11px;color:#8a8a8a;z-index:10;}
</style>
</head>
<body>
<div class="container">
  <div id="chart"></div>
  <div class="legend"></div>
</div>
<script>
const OVERLAP_CLUSTER_REMOVE_COUNT=3;
const LABEL_BBOX_PAD=2;

function median(v){
  if(!v.length)throw new Error("empty");
  v=[...v].sort((a,b)=>a-b);
  const h=Math.floor(v.length/2);
  return v.length%2?v[h]:(v[h-1]+v[h])/2
}
function truncateText(text,maxLength=18){
  if(text.length<=maxLength){
    return text
  }
  return text.substring(0,maxLength)+"..."
}
function rectanglesOverlap(rect1,rect2){
  return !(rect1.x+rect1.width<rect2.x||rect2.x+rect2.width<rect1.x||rect2.y+rect2.height<rect1.y)
}
function rectIntersectionArea(a,b){
  const x=Math.max(a.x,b.x);
  const y=Math.max(a.y,b.y);
  const w=Math.min(a.x+a.width,b.x+b.width)-x;
  const h=Math.min(a.y+a.height,b.y+b.height)-y;
  if(w<=0||h<=0){
    return 0
  }
  return w*h
}
function expandRect(rect,pad=LABEL_BBOX_PAD){
  return {x:rect.x-pad,y:rect.y-pad,width:rect.width+pad*2,height:rect.height+pad*2}
}
function getPositionOptions(centerX,centerY,radius,padding=5){
  const d=radius+padding;
  const yb=centerY+3;
  return [
    {name:"right",x:centerX+d,y:yb,anchor:"start"},
    {name:"left",x:centerX-d,y:yb,anchor:"end"},
    {name:"below",x:centerX,y:centerY+d+10,anchor:"middle"},
    {name:"above",x:centerX,y:centerY-d,anchor:"middle"},
    {name:"right-top",x:centerX+d,y:centerY-d*0.6,anchor:"start"},
    {name:"right-bottom",x:centerX+d,y:centerY+d*0.6,anchor:"start"},
    {name:"left-top",x:centerX-d,y:centerY-d*0.6,anchor:"end"},
    {name:"left-bottom",x:centerX-d,y:centerY+d*0.6,anchor:"end"}
  ]
}
function hasCollisionWithCircles(textElement,allCircles){
  try{
    const textBBox=textElement.getBBox();
    for(const circleData of allCircles){
      const r=parseFloat(circleData.circle.getAttribute('r'))||7.5;
      const circleBBox={x:circleData.coords.x-r,y:circleData.coords.y-r,width:r*2,height:r*2};
      if(rectanglesOverlap(textBBox,circleBBox)){
        return true
      }
    }
    return false
  }catch(e){
    return false
  }
}
function bestPositionSmart(textElement,centerX,centerY,radius,allCircles,fullText,placedBoxes){
  const positions=getPositionOptions(centerX,centerY,radius);
  function scoreFor(text){
    textElement.textContent=text;
    let best={pos:null,text:text,score:Infinity,circleHit:false,bbox:null};
    for(const pos of positions){
      textElement.setAttribute('x',pos.x);
      textElement.setAttribute('y',pos.y);
      textElement.setAttribute('text-anchor',pos.anchor);
      let bbox;
      try{
        bbox=expandRect(textElement.getBBox(),LABEL_BBOX_PAD);
      }catch(e){
        continue;
      }
      let circleHit=false;
      for(const c of allCircles){
        const r=parseFloat(c.circle.getAttribute('r'))||7.5;
        const circleBBox={x:c.coords.x-r,y:c.coords.y-r,width:r*2,height:r*2};
        if(rectanglesOverlap(bbox,circleBBox)){
          circleHit=true;
          break;
        }
      }
      let overlapArea=0;
      for(const pb of placedBoxes){
        overlapArea+=rectIntersectionArea(bbox,pb);
      }
      const score=(circleHit?1e9:0)+overlapArea;
      if(score<best.score){
        best={pos:pos,text:text,score:score,circleHit:circleHit,bbox:bbox};
      }
    }
    return best;
  }
  const full=scoreFor(fullText);
  if(!full.circleHit&&full.score===0){
    return {...full,hasCollision:false}
  }
  const truncated=scoreFor(truncateText(fullText,18));
  if(!truncated.circleHit&&truncated.score===0){
    return {...truncated,hasCollision:true}
  }
  if(truncated.score<=full.score){
    return {...truncated,hasCollision:true}
  }
  return {...full,hasCollision:full.circleHit||full.score>0}
}
function findMatchingDataPoint(circle){
  const bound=circle.__data__||d3.select(circle).datum();
  if(bound)return bound;
  return null
}
let customLabels=[];
let isUpdating=false;
let hoveringElements=new Set();
function loadCSV(path){
  return d3.csv(path).then(raw=>{
    const cols=raw.columns||Object.keys(raw[0]||{});
    const regionKey=cols.find(c=>c.toLowerCase().includes('region'))||'Region';
    const aiKey=cols.find(c=>c.toLowerCase().startsWith('ai index'))||cols[1];
    const computeKey=cols.find(c=>c.toLowerCase().startsWith('compute index'))||cols[2];
    const groupKey=cols.find(c=>c.toLowerCase().includes('aif'))||'aif_group_label';
    const annKey=cols.find(c=>c.toLowerCase().includes('annotate'))||'annotate_geo';
    const data=raw.map(r=>{
      const ai=+r[aiKey];
      const comp=+r[computeKey];
      return {id:r[regionKey],ai:ai,compute:comp,x:ai,y:comp,group:r[groupKey]||'Unknown',annotate:r[annKey]==='True'||r[annKey]===true||r[annKey]==='true',value:1}
    }).filter(d=>d.id);
    return {data,aiKey,computeKey}
  })
}
function buildLegend(groups,colorMap){
  const el=document.querySelector('.legend');
  if(!el)return;
  el.innerHTML='';
  groups.forEach(g=>{
    const item=document.createElement('div');
    item.className='legend-item';
    const box=document.createElement('span');
    box.className='box';
    box.style.background=colorMap[g]||'#7f7f7f';
    const label=document.createElement('span');
    label.textContent=g;
    item.appendChild(box);
    item.appendChild(label);
    el.appendChild(item);
  });
}
function drawPlot(loaded){
  const data=loaded.data;
  const aiKey=loaded.aiKey;
  const computeKey=loaded.computeKey;
  const xVals=data.map(d=>d.x).filter(Number.isFinite);
  const yVals=data.map(d=>d.y).filter(Number.isFinite);
  const aiMedian=median(xVals);
  const groups=Array.from(new Set(data.map(d=>d.group||'Unknown')));
  const palette=['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf','#393b79','#637939','#8c6d31','#843c39','#7b4173','#3182bd','#e6550d','#31a354','#756bb1','#636363'];
  const colorMap={};
  groups.forEach((g,i)=>{colorMap[g]=palette[i%palette.length];});
  data.forEach(d=>{d.color=colorMap[d.group]||'#7f7f7f';});
  const xMin=Math.min(...xVals);
  const xMax=Math.max(...xVals);
  const yMin=Math.min(...yVals);
  const yMax=Math.max(...yVals);
  const xPad=(xMax-xMin||1)*0.1;
  const yPad=(yMax-yMin||1)*0.1;
  const xDomain=[Math.max(0,xMin-xPad),xMax+xPad];
  const minY=yMin-yPad;
  const maxY=yMax+yPad;
  new d3plus.Plot()
    .select('#chart')
    .data(data)
    .annotations([{data:[{id:'Trend',x:aiMedian,y:minY},{id:'Trend',x:aiMedian,y:maxY},{id:'Baseline',x:xDomain[0],y:median(yVals)},{id:'Baseline',x:xDomain[1],y:median(yVals)}],shape:'Line',stroke:'#d9d9d9',strokeDasharray:'4 3',strokeWidth:1}])
    .groupBy('id')
    .tooltipConfig({
      body:d=>`<table class='tooltip-table'>
        <tr><td class='title'>AI Index:</td><td class='data'>${d.ai}</td></tr>
        <tr><td class='title'>Compute Index:</td><td class='data'>${d.compute}</td></tr>
        <tr><td class='title'>Group:</td><td class='data'>${d.group}</td></tr>
        <tr><td class='title'>Region:</td><td class='data'>${d.id}</td></tr>
      </table>`,
      title:d=>d.id
    })
    .size('value')
    .sizeMin(15)
    .sizeMax(15)
    .color('color')
    .label('')
    .shapeConfig({
      fillOpacity:.75,
      stroke:'#ffffff',
      strokeWidth:1.5,
      Circle:{labelConfig:{fontSize:0}}
    })
    .yConfig({
      title:computeKey,
      titleConfig:{fontSize:()=>14,fontWeight:600,fill:'#333'},
      gridConfig:{stroke:'#e9e9e9',strokeWidth:1},
      shapeConfig:{labelConfig:{fontSize:()=>12}}
    })
    .xDomain(xDomain)
    .xConfig({
      title:aiKey,
      titleConfig:{fontSize:()=>14,fontWeight:600,fill:'#333'},
      gridConfig:{stroke:'#e9e9e9',strokeWidth:1},
      shapeConfig:{labelConfig:{fontSize:()=>12}}
    })
    .legend(false)
    .downloadButton(false)
    .render();
  buildLegend(groups,colorMap);
  setTimeout(()=>{initializeCustomLabels();startPositionUpdater();},500);
}
function initializeCustomLabels(){
  const svg=document.querySelector('#chart svg');
  if(!svg){
    setTimeout(initializeCustomLabels,100);
    return
  }
  const circles=svg.querySelectorAll('circle');
  customLabels=[];
  hoveringElements=new Set();
  circles.forEach(circle=>{
    const matchingData=findMatchingDataPoint(circle);
    if(matchingData){
      const fullText=matchingData.id;
      const text=document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('class','custom-label');
      text.setAttribute('data-id',matchingData.id);
      text.setAttribute('text-anchor','start');
      text.setAttribute('font-family','Helvetica Neue, Arial, sans-serif');
      text.setAttribute('font-size','10');
      text.setAttribute('fill','#000');
      text.setAttribute('font-weight','normal');
      text.textContent=fullText;
      svg.appendChild(text);
      customLabels.push({circle:circle,text:text,data:matchingData,fullText:fullText,defaultText:fullText,savedPosition:null,hiddenByCluster:false,wasHiddenBeforeHover:false});
      circle.addEventListener('mouseenter',()=>{
        hoveringElements.add(text);
        const labelData=customLabels.find(l=>l.circle===circle);
        if(labelData){
          labelData.savedPosition={x:text.getAttribute('x'),y:text.getAttribute('y'),anchor:text.getAttribute('text-anchor'),content:text.textContent};
          labelData.wasHiddenBeforeHover=labelData.hiddenByCluster;
          labelData.hiddenByCluster=false;
        }
        text.classList.add('hover');
        text.textContent=fullText;
        text.setAttribute('opacity','1');
        text.style.display='';
        text.style.pointerEvents='auto';
      });
      circle.addEventListener('mouseleave',()=>{
        hoveringElements.delete(text);
        text.classList.remove('hover');
        const labelData=customLabels.find(l=>l.circle===circle);
        if(labelData&&labelData.savedPosition){
          text.setAttribute('x',labelData.savedPosition.x);
          text.setAttribute('y',labelData.savedPosition.y);
          text.setAttribute('text-anchor',labelData.savedPosition.anchor);
          text.textContent=labelData.savedPosition.content;
          labelData.hiddenByCluster=labelData.wasHiddenBeforeHover;
          labelData.wasHiddenBeforeHover=false;
        }
        if(customLabels.find(l=>l.text===text)?.hiddenByCluster){
          text.style.display='none';
          text.style.pointerEvents='none';
        }else{
          text.style.display='';
          text.style.pointerEvents='auto';
        }
      });
    }
  });
  updateLabelPositions();
}
function updateLabelPositions(){
  if(isUpdating)return;
  isUpdating=true;
  const svg=document.querySelector('#chart svg');
  if(!svg){
    isUpdating=false;
    return
  }
  const circlePositions=[];
  customLabels.forEach(({circle,text})=>{
    if(circle&&text){
      const bbox=circle.getBoundingClientRect();
      const svgRect=svg.getBoundingClientRect();
      const svgPoint=svg.createSVGPoint();
      svgPoint.x=bbox.left+bbox.width/2-svgRect.left;
      svgPoint.y=bbox.top+bbox.height/2-svgRect.top;
      const screenCTM=svg.getScreenCTM();
      if(screenCTM){
        const svgCoords=svgPoint.matrixTransform(screenCTM.inverse());
        circlePositions.push({circle:circle,coords:svgCoords});
      }
    }
  });
  const labels=customLabels.slice();
  labels.sort((a,b)=>{
    const ha=hoveringElements.has(a.text)?-1:0;
    const hb=hoveringElements.has(b.text)?-1:0;
    if(ha!==hb)return ha-hb;
    const ax=circlePositions.find(cp=>cp.circle===a.circle)?.coords.x||0;
    const bx=circlePositions.find(cp=>cp.circle===b.circle)?.coords.x||0;
    return ax-bx
  });
  const placedBoxes=[];
  labels.forEach(labelData=>{
    const {circle,text,fullText}=labelData;
    if(!circle||!text){
      return
    }
    if(hoveringElements.has(text)){
      try{
        placedBoxes.push(expandRect(text.getBBox(),LABEL_BBOX_PAD));
      }catch(e){}
      return
    }
    const circleData=circlePositions.find(cp=>cp.circle===circle);
    if(!circleData){
      return
    }
    const r=parseFloat(circle.getAttribute('r'))||7.5;
    const best=bestPositionSmart(text,circleData.coords.x,circleData.coords.y,r,circlePositions,fullText,placedBoxes);
    text.setAttribute('x',best.pos.x);
    text.setAttribute('y',best.pos.y);
    text.setAttribute('text-anchor',best.pos.anchor);
    text.textContent=best.text;
    labelData.defaultText=best.text;
    if(best.hasCollision){
      text.classList.add('collision');
      if(!labelData.hiddenByCluster)text.setAttribute('opacity','0.35');
    }else{
      text.classList.remove('collision');
      if(!labelData.hiddenByCluster)text.setAttribute('opacity','1');
    }
    try{
      placedBoxes.push(expandRect(text.getBBox(),LABEL_BBOX_PAD));
    }catch(e){}
    if(labelData.hiddenByCluster){
      text.style.display='none';
      text.style.pointerEvents='none';
    }else{
      text.style.display='';
      text.style.pointerEvents='auto';
    }
  });
  hideClustersOfThreeOrMore();
  isUpdating=false;
}
function hideClustersOfThreeOrMore(){
  const labels=customLabels.filter(ld=>ld.text&&ld.circle);
  const n=labels.length;
  const boxes=new Array(n);
  for(let i=0;i<n;i++){
    try{
      boxes[i]=expandRect(labels[i].text.getBBox(),LABEL_BBOX_PAD);
    }catch(e){
      boxes[i]=null;
    }
  }
  const adj=Array.from({length:n},()=>[]);
  for(let i=0;i<n;i++){
    if(!boxes[i])continue;
    for(let j=i+1;j<n;j++){
      if(!boxes[j])continue;
      if(rectanglesOverlap(boxes[i],boxes[j])){
        adj[i].push(j);
        adj[j].push(i);
      }
    }
  }
  const visited=new Array(n).fill(false);
  for(let i=0;i<n;i++){
    if(visited[i])continue;
    const stack=[i];
    const comp=[];
    while(stack.length){
      const v=stack.pop();
      if(visited[v])continue;
      visited[v]=true;
      comp.push(v);
      for(const u of adj[v]){
        if(!visited[u])stack.push(u);
      }
    }
    if(comp.length>=OVERLAP_CLUSTER_REMOVE_COUNT){
      for(const idx of comp){
        const ld=labels[idx];
        if(hoveringElements.has(ld.text))continue;
        ld.hiddenByCluster=true;
        ld.text.style.display='none';
        ld.text.style.pointerEvents='none';
      }
    }else{
      for(const idx of comp){
        const ld=labels[idx];
        if(hoveringElements.has(ld.text))continue;
        ld.hiddenByCluster=false;
        ld.text.style.display='';
        if(ld.text.classList.contains('collision')){
          ld.text.setAttribute('opacity','0.35');
        }else{
          ld.text.setAttribute('opacity','1');
        }
        ld.text.style.pointerEvents='auto';
      }
    }
  }
}
function startPositionUpdater(){
  function updateLoop(){
    updateLabelPositions();
    requestAnimationFrame(updateLoop);
  }
  updateLoop();
  const chartElement=document.getElementById('chart');
  if(chartElement){
    chartElement.addEventListener('wheel',updateLabelPositions,{passive:true});
    chartElement.addEventListener('mousedown',updateLabelPositions);
    chartElement.addEventListener('mousemove',updateLabelPositions);
    chartElement.addEventListener('mouseup',updateLabelPositions);
  }
}
loadCSV('fig2.csv').then(drawPlot);
</script>
<div class="footer-note">Color indicates AIF group.</div>
</body>
</html>