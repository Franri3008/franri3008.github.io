<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Fig 8</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
:root{--bg:#ffffff;--axis:#cfcfcf;--grid:#e9e9e9;--text:#6b6b6b;--text-strong:#333333;--muted:#9aa0a6;}
html,body{height:100%;}
body{margin:0;overflow:hidden;background:var(--bg);font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;color:var(--text);}
.viz-grid{display:grid;grid-template-rows:1fr auto;grid-template-columns:1fr;height:100vh;width:100vw;gap:0;padding:0;}
#container1{grid-row:1;grid-column:1;display:flex;min-height:0;min-width:0;}
#container2{grid-row:2;grid-column:1;display:flex;align-items:center;justify-content:center;padding:10px 14px;border-top:1px solid rgba(0,0,0,0.08);background:#fff;gap:16px;flex-wrap:wrap;}
#viz{position:relative;flex:1 1 auto;min-width:0;min-height:0;}
#chart{display:block;width:100%;height:100%;}
#tooltip{position:absolute;background:#ffffff;border:1px solid #e5e5e5;border-radius:8px;padding:6px 8px;font-size:12px;pointer-events:none;opacity:0;box-shadow:0 10px 24px rgba(0,0,0,.1);} 
.custom-legend{display:flex;flex-wrap:wrap;align-items:center;justify-content:center;gap:clamp(6px,1.5vw,14px);background:rgba(255,255,255,0.9);padding:clamp(6px,1.2vh,10px) clamp(10px,2vw,16px);border-radius:clamp(6px,1.2vw,12px);box-shadow:0 2px 8px rgba(0,0,0,0.1);max-width:100%;}
.legend-item{display:flex;align-items:center;gap:6px;cursor:pointer;transition:opacity .2s ease;font-weight:600;color:#333;font-size:clamp(11px,1.4vw,14px);} 
.legend-item.dim{opacity:.35;} 
.legend-item:focus-visible{outline:2px solid rgba(0,0,0,0.45);outline-offset:2px;} 
.legend-square{width:clamp(10px,1.2vw,14px);height:clamp(10px,1.2vw,14px);border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,0.15) inset;} 
.legend-block{display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:center;margin:0 8px;}
.legend-title{font-weight:700;color:var(--text-strong);font-size:12px;margin-right:4px;}
.axis path.domain{stroke:var(--axis);} 
.axis .tick line{stroke:var(--grid);} 
.axis .tick text{fill:var(--text);font-size:12px;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;} 
</style>
</head>
<body>
<div class="viz-grid">
  <div id="container1">
    <div id="viz">
      <svg id="chart"></svg>
      <div id="tooltip"></div>
    </div>
  </div>
  <div id="container2">
    <div class="legend-block" id="legend-block-groups">
      <div class="legend-title">Link to AI Factory</div>
      <div class="custom-legend" id="legend-groups"></div>
    </div>
    <div class="legend-block" id="legend-block-metrics">
      <div class="legend-title">Metric</div>
      <div class="custom-legend" id="legend-metrics"></div>
    </div>
  </div>
</div>
<script>
let data=[];
let keys=[];
let labels={};
const NO_MATCH_LABEL = "No match";
const NO_MATCH_COLOR = "#848683";
const GROUP_COLOR_MAP = {
  "NUTS-2 match":"#207164",
  "Country match":"#F3C64C",
  "Partner country":"#7470B3",
  "No match":NO_MATCH_COLOR
};
const colorPalette={
  "Number of vacancies":"#6082a4",
  "Share of vacancies":"#d8e0e9"
};
const svg=d3.select("#chart");
const tooltip=d3.select("#tooltip");
let activeKey=null;
let groupByRegion = new Map();
function updateHighlight(){
  const bars=d3.selectAll('.bar-seg');
  bars.transition().duration(150).style('opacity', d=> activeKey && d.key!==activeKey ? 0.25 : 1);
  const lbls=d3.selectAll('g.segment-labels text');
  lbls.transition().duration(150).style('opacity', d=> activeKey && d.key!==activeKey ? 0.25 : 1);
};
function updateLegendStyles(){
  d3.select('#legend-metrics').selectAll('.legend-item')
    .classed('dim', d=> activeKey && d!==activeKey)
    .attr('aria-pressed', d=> activeKey===d ? 'true' : 'false');
};
function wrapTicks(selection, width, lineHeight=1.2, maxLines=3, xPos=0){
  selection.each(function(){
    const text=d3.select(this);
    const words=text.text().split(/\s+/);
    const y=text.attr("y");
    const baseDy=parseFloat(text.attr("dy"))||0;
    text.text(null);
    let line=[]; let lineNumber=0;
    let tspan=text.append("tspan").attr("x",xPos).attr("y",y).attr("dy",baseDy+"em");
    for(let i=0;i<words.length;i++){
      line.push(words[i]);
      tspan.text(line.join(" "));
      if(tspan.node().getComputedTextLength()>width){
        line.pop();
        tspan.text(line.join(" "));
        line=[words[i]];
        lineNumber++;
        if(lineNumber>=maxLines){
          let prev=tspan;
          let txt=prev.text();
          while(prev.node().getComputedTextLength()>width && txt.length>0){ txt=txt.slice(0,-1); prev.text(txt); }
          prev.text(txt.replace(/\s+$/,'')+"â€¦");
          return;
        }
        tspan=text.append("tspan").attr("x",xPos).attr("y",y).attr("dy",(baseDy+lineNumber*lineHeight)+"em").text(words[i]);
      }
    }
  });
};
function buildMetricLegend(){
  const el=d3.select("#legend-metrics");
  el.selectAll("*").remove();
  const items=el.selectAll("div.legend-item").data(keys).enter()
    .append("div")
    .attr("class","legend-item")
    .attr("role","button")
    .attr("tabindex",0)
    .attr("aria-pressed","false");
  items.append("div").attr("class","legend-square").style("background", d=>colorPalette[d] || "#7f7f7f");
  items.append("span").text(d=>labels[d] || d);
  function toggleKey(event, d){
    activeKey = (activeKey === d ? null : d);
    updateLegendStyles();
    updateHighlight();
  };
  items.on('click', toggleKey)
    .on('keydown', function(event, d){
      if(event.key === 'Enter' || event.key === ' '){
        event.preventDefault();
        toggleKey(event, d);
      }
    });
  updateLegendStyles();
}
function buildGroupLegend(){
  const order=["Country match","NUTS-2 match","Partner country",NO_MATCH_LABEL];
  const values=Array.from(new Set(Array.from(groupByRegion.values())));
  const legendValues=order.filter(v=>values.includes(v)).concat(values.filter(v=>!order.includes(v)));
  const el=d3.select("#legend-groups");
  el.selectAll("*").remove();
  const items=el.selectAll("div.legend-item").data(legendValues).enter()
    .append("div").attr("class","legend-item");
  items.append("div").attr("class","legend-square").style("background", d=>GROUP_COLOR_MAP[d] || NO_MATCH_COLOR);
  items.append("span").text(d=>d);
}
function render(){
  if(!data.length){ return; }
  const viz=document.getElementById("viz");
  const rect=viz.getBoundingClientRect();
  const fullW=rect.width;
  const fullH=rect.height;
  const tickFont=Math.max(8, Math.min(13, fullW/110));
  // axisContainer is not used now, set margin.left to a sensible default
  const axisContainerWidth = 0;
  const measureCtx=render._measureCtx || (render._measureCtx=document.createElement('canvas').getContext('2d'));
  const fontFamily=window.getComputedStyle(document.body).fontFamily || 'system-ui, -apple-system, "Segoe UI", sans-serif';
  measureCtx.font=`${tickFont}px ${fontFamily}`;
  const maxLabelWidth=d3.max(data, d=>measureCtx.measureText(d.category).width) || 0;
  const labelGap=Math.max(14, Math.min(26, Math.round(fullW*0.03)));
  const axisOffset = labelGap - 2;
  const spacing = 4;
  const minMarginLeft = axisContainerWidth + spacing;
  const computedMarginLeft = Math.ceil(maxLabelWidth + axisContainerWidth + spacing - axisOffset);
  const margin={
    top:12,
    right:48,
    bottom:36,
    left:Math.max(minMarginLeft, computedMarginLeft)
  };
  svg.attr("width",fullW).attr("height",fullH);
  const width=fullW-margin.left-margin.right;
  const height=fullH-margin.top-margin.bottom;
  const defs=svg.selectAll('defs').data([null]).join('defs');
  defs.select('#rowWhiteFade').remove();
  defs.select('#rowGrayFade').remove();
  const gW=defs.append('linearGradient').attr('id','rowWhiteFade').attr('gradientUnits','userSpaceOnUse').attr('x1',0).attr('x2',fullW).attr('y1',0).attr('y2',0);
  gW.append('stop').attr('offset','0%').attr('stop-color','#ffffff').attr('stop-opacity',0);
  gW.append('stop').attr('offset','6%').attr('stop-color','#ffffff').attr('stop-opacity',1);
  gW.append('stop').attr('offset','100%').attr('stop-color','#ffffff').attr('stop-opacity',1);
  const gG=defs.append('linearGradient').attr('id','rowGrayFade').attr('gradientUnits','userSpaceOnUse').attr('x1',0).attr('x2',fullW).attr('y1',0).attr('y2',0);
  gG.append('stop').attr('offset','0%').attr('stop-color','#f0efe9').attr('stop-opacity',0);
  gG.append('stop').attr('offset','6%').attr('stop-color','#f0efe9').attr('stop-opacity',1);
  gG.append('stop').attr('offset','100%').attr('stop-color','#f0efe9').attr('stop-opacity',1);
  const gRoot=svg.selectAll("g.root").data([null]).join("g").attr("class","root").attr("transform",`translate(${margin.left},${margin.top})`);
  const maxSum=d3.max(data, d=> keys.reduce((s,k)=> s + (+d[k]||0), 0)) || 0;
  const x=d3.scaleLinear().domain([0, maxSum]).range([labelGap,width]);
  const y=d3.scaleBand().domain(data.map(d=>d.category)).range([0,height]).paddingInner(0.28);
  const stack=d3.stack().keys(keys).value((d,k)=>d[k]);
  const series=stack(data);
  const rowBG=gRoot.selectAll("rect.row").data(data.map(d=>d.category));
  const step=y.step();
  const pad=(step-y.bandwidth())/2;
  rowBG.join(
    enter=>enter.append("rect").attr("class","row").attr("x",0).attr("y",d=>y(d)-pad).attr("width",fullW).attr("height",step).attr("fill",(d,i)=>i%2?"url(#rowGrayFade)":"url(#rowWhiteFade)"),
    update=>update.attr("x",0).attr("y",d=>y(d)-pad).attr("width",fullW).attr("height",step)
  );
  const layers=gRoot.selectAll("g.layer").data(series,d=>d.key).join(enter=>enter.append("g").attr("class","layer").attr("fill",d=>colorPalette[d.key] || "#7f7f7f"));
  const barH=Math.max(2,y.bandwidth()*0.6);
  layers.selectAll("rect").data(d=>d.map(v=>({key:d.key,cat:v.data.category,v:v}))).join("rect").attr("class","bar-seg")
    .attr("x",d=>x(d.v[0]))
    .attr("y",d=>y(d.cat)+(y.bandwidth()-barH)/2)
    .attr("width",d=>Math.max(0.5,x(d.v[1])-x(d.v[0])))
    .attr("height",barH)
    .on("mouseenter",(event,d)=>{ d3.select(event.currentTarget).style("filter",`drop-shadow(0 0 8px ${colorPalette[d.key] || "#7f7f7f"})`); })
    .on("mousemove",(event,d)=>{
      const val=(d.v[1]-d.v[0]);
      let str=(Math.round(val*10)/10).toString();
      if(str.endsWith('.0')){ str=str.slice(0,-2); }
      tooltip.style("opacity",1).style("left",event.pageX+10+"px").style("top",event.pageY-12+"px").html(`${labels[d.key] || d.key}: ${str}`);
    })
    .on("mouseleave",function(){ tooltip.style("opacity",0); d3.select(this).style("filter",null); });
  const segData=series.flatMap(s=>s.map(v=>({key:s.key,cat:v.data.category,v:v})));
  const labelsG=gRoot.selectAll("g.segment-labels").data([null]).join("g").attr("class","segment-labels");
  const labelFont=Math.max(7, Math.min(11, fullW/140));
  const labelsSel=labelsG.selectAll("text").data(segData, d=>d.key+"::"+d.cat);
  labelsSel.join(
    enter=>enter.append("text")
      .attr("text-anchor","middle")
      .attr("dy","0.35em")
      .style("fill","#ffffff")
      .style("font-weight","600")
      .style("pointer-events","none"),
    update=>update
  )
  .style("font-size",labelFont+"px")
  .attr("x",d=>x(d.v[0])+(x(d.v[1])-x(d.v[0]))/2)
  .attr("y",d=>y(d.cat)+y.bandwidth()/2)
  .text(function(d){
    const raw=d.v[1]-d.v[0];
    let str=(Math.round(raw*10)/10).toString();
    if(str.endsWith('.0')){ str=str.slice(0,-2); }
    return str;
  })
  .each(function(d){
    const segPx=x(d.v[1])-x(d.v[0]);
    const pad=4;
    const minH=labelFont*0.9;
    const textWidth=this.getComputedTextLength();
    const enoughWidth=(segPx >= textWidth + pad*2);
    const enoughHeight=(barH >= minH);
    d3.select(this).attr("visibility", (enoughWidth && enoughHeight) ? "visible" : "hidden");
  });
  const xAxis=gRoot.selectAll("g.x").data([null]).join("g").attr("class","axis x").attr("transform",`translate(0,${y.range()[1]})`);
  const tickCount=Math.max(4, Math.round(width/100));
  xAxis.call(d3.axisBottom(x).ticks(tickCount));
  xAxis.selectAll("text.axis-title").data([null]).join("text")
    .attr("class","axis-title")
    .attr("x", (labelGap + width) / 2)
    .attr("y", 28)
    .style("fill", "var(--text-strong)")
    .style("font-weight", 700)
    .style("font-size", "14px")
    .text("Advanced AI Skills Demand");
  const yAxis=gRoot.selectAll("g.y").data([null]).join("g").attr("class","axis y");
  const padTicks=Math.max(4, Math.min(12, labelGap*0.35));
  yAxis.attr("transform", `translate(${axisOffset},0)`)
    .call(d3.axisLeft(y).tickSize(0).tickPadding(padTicks));
  yAxis.selectAll("path").remove();
  // color y-axis tick labels by group
  yAxis.selectAll("g.tick text").each(function(d){
    const g = groupByRegion.get(d) || NO_MATCH_LABEL;
    const color = GROUP_COLOR_MAP[g] || NO_MATCH_COLOR;
    d3.select(this).style("fill", color).style("font-weight", 600);
  });
  const wrapWidth=Math.max(maxLabelWidth + 6, margin.left - axisOffset - 8);
  const maxLines=Math.max(1, Math.min(3, Math.floor((y.bandwidth()*0.95)/(tickFont*1.25))));
  const tickX = -2;
  yAxis.selectAll("text")
    .style("font-size", tickFont+"px")
    .call(wrapTicks, wrapWidth, 1.12, maxLines, tickX)
    .style("text-anchor","end")
    .attr("x", tickX)
    .attr("dx", 0);
  yAxis.selectAll("text tspan").attr("x", tickX);
  yAxis.selectAll("g.tick").each(function(d){
    const g=d3.select(this);
    const t=g.select("text");
    const bb=t.node().getBBox();
    const desired=y(d)+y.bandwidth()/2;
    const current=bb.y+bb.height/2;
    const dy=desired-current;
    g.attr("transform",`translate(0,${dy})`);
  });
  updateHighlight();
};
function loadData(){
  d3.csv("fig8.csv").then(raw=>{
    const metricSet=new Set(raw.map(d=>d.Metric));
    keys=Array.from(metricSet);
    keys.sort();
    labels={};
    keys.forEach(k=> labels[k]=k);
    const byRegion=d3.group(raw, d=>d.Region);
    // store group label per region
    groupByRegion = new Map();
    byRegion.forEach((rows, region)=>{
      const grp = rows.find(r=>r.aif_group_label!=null)?.aif_group_label || NO_MATCH_LABEL;
      const norm = (function(t){
        const l=String(t||"").toLowerCase();
        if(!t||l==="no match"||l==="nomatch"||l==="none")return NO_MATCH_LABEL;
        if(l==="partner country"||l==="partner-country"||l==="partner")return "Partner country";
        if(l==="country match"||l==="country-match"||l==="country")return "Country match";
        if(l==="nuts-2 match"||l==="nuts2 match"||l==="nuts2-match"||l==="nuts2"||l==="nuts-2")return "NUTS-2 match";
        return String(t);
      })(grp);
      groupByRegion.set(region, norm);
    });
    // build row objects
    data=Array.from(byRegion, ([region, rows])=>{
      const o={category:region};
      keys.forEach(k=> o[k]=0);
      rows.forEach(r=>{ o[r.Metric]=+r["Advanced AI Skills Demand"]; });
      return o;
    });
    buildGroupLegend();
    buildMetricLegend();
    render();
  });
};
loadData();
window.addEventListener("resize", function(){ render(); });
var vizEl = document.getElementById('viz');
if (typeof ResizeObserver !== 'undefined' && vizEl) {
  var chartObserver = new ResizeObserver(function(){ render(); });
  chartObserver.observe(vizEl);
};
</script>
</body>
</html>
