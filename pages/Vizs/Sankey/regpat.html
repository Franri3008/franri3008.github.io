<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      font-family: sans-serif;
    }
    svg {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    .links path {
      fill: none;
      stroke-opacity: 0.4;
      transition: all 0.3s ease;
    }
    .nodes rect {
      stroke-width: 1px;
      transition: all 0.3s ease;
    }
    .nodes text {
      font-size: 14px;
      pointer-events: none;
      transition: all 0.3s ease;
    }
    .hoveredNode rect {
      filter: drop-shadow(0 0 5px #fff);
      stroke-width: 2px;
    }
    .hoveredNode text {
      font-size: 16px;
      stroke: #fff;
      stroke-width: 2px;
      paint-order: stroke fill;
      font-weight: bold;
    }
    .hoveredLink {
      stroke-opacity: 1 !important;
      filter: drop-shadow(0 0 5px #fff);
    }
    .dimmedNode rect {
      fill: #ccc !important;
      stroke: #ccc !important;
      filter: none;
    }
    .dimmedNode text {
      fill: #666 !important;
      stroke: none;
      font-weight: normal;
      font-size: 14px;
    }
    .dimmedLink {
      stroke: #ccc !important;
      filter: none;
    }
    .tooltip {
      position: absolute;
      text-align: left;
      padding: 4px;
      background: #fff;
      border: 1px solid #ccc;
      font-size: 12px;
      pointer-events: none;
    }
  </style>
</head>
<body>
<svg></svg>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>
  const svg = d3.select("svg")
    .attr("width", window.innerWidth)
    .attr("height", window.innerHeight)
    .attr("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`);

  let width = window.innerWidth;
  let height = window.innerHeight;

  const sankey = d3.sankey()
      .nodeWidth(20)
      .nodePadding(16)
      .size([width, height]);

  const linkPath = d3.sankeyLinkHorizontal();
  const tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

  d3.csv("regpat.csv").then(rawData => {
    const cleanData = rawData
      .map(row => {
        const from = row.from ? row.from.trim() : null;
        const to = row.to ? row.to.trim() : null;
        const parent = row.parent ? row.parent.trim() : null;
        const color = row.color ? row.color.trim() : null;
        const value = row.count ? +row.count : NaN;
        return { from, to, parent, color, value };
      })
      .filter(d => d.from && d.to && d.parent && Number.isFinite(d.value));

    const fromParentMap = new Map();
    const nodeColorMap = new Map();
    cleanData.forEach(d => {
      if (!fromParentMap.has(d.from)) {
        fromParentMap.set(d.from, d.parent);
      }
      if (d.color) {
        if (!nodeColorMap.has(d.parent)) {
          nodeColorMap.set(d.parent, d.color);
        }
        if (!nodeColorMap.has(d.from)) {
          nodeColorMap.set(d.from, d.color);
        }
      }
    });

    function buildGraph(data) {
      const parentNames = Array.from(new Set(data.map(d => d.parent)));
      const fromNames = Array.from(new Set(data.map(d => d.from)));
      const toNames = Array.from(new Set(data.map(d => d.to)));

      const parentNodes = parentNames.map(name => ({
        name,
        type: "parent",
        color: nodeColorMap.get(name) || "#b3b3b3"
      }));

      const fromNodes = fromNames.map(name => {
        const parent = fromParentMap.get(name);
        const color = nodeColorMap.get(name) || nodeColorMap.get(parent) || "#b3b3b3";
        return { name, type: "from", color };
      });

      const toNodes = toNames.map(name => ({
        name,
        type: "to",
        color: "#d0d0d0"
      }));

      const nodes = parentNodes.concat(fromNodes, toNodes);

      const parentIndexMap = new Map(parentNames.map((name, i) => [name, i]));
      const fromStart = parentNames.length;
      const fromIndexMap = new Map(fromNames.map((name, i) => [name, fromStart + i]));
      const toStart = fromStart + fromNames.length;
      const toIndexMap = new Map(toNames.map((name, i) => [name, toStart + i]));

      const parentFromLinks = new Map();
      const fromToLinks = new Map();

      data.forEach(d => {
        const parentIdx = parentIndexMap.get(d.parent);
        const fromIdx = fromIndexMap.get(d.from);
        const toIdx = toIndexMap.get(d.to);

        if (parentIdx === undefined || fromIdx === undefined || toIdx === undefined) {
          return;
        }

        const color = nodeColorMap.get(d.from) || nodeColorMap.get(d.parent) || "#999";

        const pfKey = `${d.parent}|${d.from}`;
        let pfLink = parentFromLinks.get(pfKey);
        if (!pfLink) {
          pfLink = {
            source: parentIdx,
            target: fromIdx,
            value: 0,
            color
          };
          parentFromLinks.set(pfKey, pfLink);
        }
        pfLink.value += d.value;

        const ftKey = `${d.from}|${d.to}`;
        let ftLink = fromToLinks.get(ftKey);
        if (!ftLink) {
          ftLink = {
            source: fromIdx,
            target: toIdx,
            value: 0,
            color
          };
          fromToLinks.set(ftKey, ftLink);
        }
        ftLink.value += d.value;
      });

      const links = Array.from(parentFromLinks.values())
        .concat(Array.from(fromToLinks.values()))
        .filter(l => l.value > 0);

      return { nodes, links };
    }

    function render() {
      svg.selectAll("*").remove();
      svg
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", `0 0 ${width} ${height}`);

      sankey.size([width, height]);

      const graph = buildGraph(cleanData);
      sankey(graph);

      const linkSelection = svg.append("g")
        .attr("class", "links")
        .selectAll("path")
        .data(graph.links)
        .enter().append("path")
          .attr("d", linkPath)
          .attr("stroke-width", d => Math.max(1, d.width))
          .attr("stroke", d => d.color);

      const nodeSelection = svg.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(graph.nodes)
        .enter().append("g")
          .attr("transform", d => `translate(${d.x0},${d.y0})`);

      nodeSelection.append("rect")
          .attr("height", d => d.y1 - d.y0)
          .attr("width", sankey.nodeWidth())
          .attr("fill", d => d.color || "#b3b3b3")
          .attr("stroke", "#999");

      nodeSelection.append("text")
          .attr("x", -6)
          .attr("y", d => (d.y1 - d.y0) / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "end")
          .attr("fill", "#000")
          .text(d => d.name)
          .filter(d => d.x0 < width / 2)
          .attr("x", 6 + sankey.nodeWidth())
          .attr("text-anchor", "start");

      nodeSelection
        .on("mouseover", function(d) {
          d3.select(this).style("cursor", "pointer");
          tooltip.transition().duration(200).style("opacity", 0.9);
          tooltip.html("Name: " + d.name + "<br/>Total: " + d.value)
            .style("left", (d3.event.pageX + 10) + "px")
            .style("top", (d3.event.pageY - 28) + "px");

          const nodeIndex = d.index;
          const connectedLinks = graph.links.filter(l => l.source.index === nodeIndex || l.target.index === nodeIndex);
          const connectedNodes = new Set([nodeIndex]);
          connectedLinks.forEach(l => {
            connectedNodes.add(l.source.index);
            connectedNodes.add(l.target.index);
          });

          nodeSelection.classed("dimmedNode", true).classed("hoveredNode", false);
          linkSelection.classed("dimmedLink", true).classed("hoveredLink", false);

          nodeSelection.filter(nd => connectedNodes.has(nd.index))
            .classed("dimmedNode", false)
            .classed("hoveredNode", true);
          linkSelection.filter(ld => connectedLinks.includes(ld))
            .classed("dimmedLink", false)
            .classed("hoveredLink", true);
        })
        .on("mousemove", function() {
          tooltip
            .style("left", (d3.event.pageX + 10) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
          tooltip.transition().duration(200).style("opacity", 0);
          nodeSelection.classed("hoveredNode", false).classed("dimmedNode", false);
          linkSelection.classed("hoveredLink", false).classed("dimmedLink", false);
          d3.select(this).style("cursor", null);
        });

      linkSelection
        .on("mouseover", function(d) {
          d3.select(this).style("cursor", "pointer");
          tooltip.transition().duration(200).style("opacity", 0.9);
          const sourceName = graph.nodes[d.source.index].name;
          const targetName = graph.nodes[d.target.index].name;
          tooltip.html("Source: " + sourceName + "<br/>Target: " + targetName + "<br/>Value: " + d.value)
            .style("left", (d3.event.pageX + 10) + "px")
            .style("top", (d3.event.pageY - 28) + "px");

          const connectedNodes = new Set([d.source.index, d.target.index]);
          nodeSelection.classed("dimmedNode", true).classed("hoveredNode", false);
          linkSelection.classed("dimmedLink", true).classed("hoveredLink", false);

          nodeSelection.filter(nd => connectedNodes.has(nd.index))
            .classed("dimmedNode", false)
            .classed("hoveredNode", true);
          d3.select(this).classed("dimmedLink", false).classed("hoveredLink", true);
        })
        .on("mousemove", function() {
          tooltip
            .style("left", (d3.event.pageX + 10) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
          tooltip.transition().duration(200).style("opacity", 0);
          nodeSelection.classed("hoveredNode", false).classed("dimmedNode", false);
          linkSelection.classed("hoveredLink", false).classed("dimmedLink", false);
          d3.select(this).style("cursor", null);
        });
    }

    render();

    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      render();
    });
  });
</script>
</body>
</html>
